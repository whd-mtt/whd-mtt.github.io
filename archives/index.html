<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="dIcXMeY8Ya" />
    
    <title>文章归档 | whd-mtt&#39;s blogs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="whd-mtt, javaweb, 大数据," >
    <meta name="description" content="whd-mtt个人前端小站" >

    
    <link rel="alternative" href="/atom.xml" title="whd-mtt&#39;s blogs" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="/favicon.ico" >
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">whd-mtt&#39;s blogs</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/whd-mtt" target="_blank">Github</a>
                        |
                    
                        <a href="" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="https://weibo.com/5048947954/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="https://avatars0.githubusercontent.com/u/18564649?s=460&v=4" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
            
        </strong>
    </h3>
    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/并发编程/">并发编程</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/08/01/并发编程之ConcurrentHashMap原理分析/">
    		并发编程之ConcurrentHashMap原理分析
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-08-01T13:03:20.000Z">2018-08-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/java/" title="java">java</a> / 
    
        <a href="/tags/并发编程/" title="并发编程">并发编程</a> / 
    
        <a href="/tags/数据结构/" title="数据结构">数据结构</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>&emsp;&emsp;在并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable和Collections.synchronizedMap()，前者在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS和锁分段的技术来减少锁竞争对于性能的影响，接下来我将分别阐述ConcurrentHashMap在JDK6/7/8分别是如何实现的。</p>
<h2 id="1-JDK1-6和1-7中的实现"><a href="#1-JDK1-6和1-7中的实现" class="headerlink" title="1. JDK1.6和1.7中的实现"></a>1. JDK1.6和1.7中的实现</h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h3><p>在jdk1.6和1.7中采用了锁分段的技术实现，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争，相比于HashTable对整个map加锁的设计，分段锁大大的提高了高并发环境下的处理能力，正因为不是对整个map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的；</p>
<p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p>
<pre><code>static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
</code></pre><h3 id="1-2-并发度（Concurrency-Level）"><a href="#1-2-并发度（Concurrency-Level）" class="headerlink" title="1.2 并发度（Concurrency Level）"></a>1.2 并发度（Concurrency Level）</h3><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p>
<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）。</p>
<h3 id="1-3-创建分段锁"><a href="#1-3-创建分段锁" class="headerlink" title="1.3 创建分段锁"></a>1.3 创建分段锁</h3><p>和JDK6不同，JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。</p>
<p>ensureSegment可能在并发环境下被调用，但与想象中不同，ensureSegment并未使用锁来控制竞争，而是使用了Unsafe对象的getObjectVolatile()提供的原子读语义结合CAS来确保Segment创建的原子性。代码段如下：<br>    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                == null) { // recheck<br>                Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);<br>                while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                       == null) {<br>                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))<br>                        break;<br>                }<br>}</p>
<h3 id="1-4-put-putIfAbsent-putAll"><a href="#1-4-put-putIfAbsent-putAll" class="headerlink" title="1.4 put/putIfAbsent/putAll"></a>1.4 put/putIfAbsent/putAll</h3><p>和JDK6一样，ConcurrentHashMap的put方法被代理到了对应的Segment（定位Segment的原理之前已经描述过）中。与JDK6不同的是，JDK7版本的ConcurrentHashMap在获得Segment锁的过程中，做了一定的优化 - 在真正申请锁之前，put方法会通过tryLock()方法尝试获得锁，在尝试获得锁的过程中会对对应hashcode的链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数后仍无法获得锁，则通过lock申请锁。</p>
<p>需要注意的是，由于在并发环境下，其他线程的put，rehash或者remove操作可能会导致链表头结点的变化，因此在过程中需要进行检查，如果头结点发生变化则重新对表进行遍历。而如果其他线程引起了链表中的某个节点被删除，即使该变化因为是非原子写操作（删除节点后链接后续节点调用的是Unsafe.putOrderedObject()，该方法不提供原子写语义）可能导致当前线程无法观察到，但因为不影响遍历的正确性所以忽略不计。</p>
<p>之所以在获取锁的过程中对整个链表进行遍历，主要目的是希望遍历的链表被CPU cache所缓存，为后续实际put过程中的链表遍历操作提升性能。</p>
<p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值，否则新建一个HashEntry节点，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p>
<p>put方法中，链接新节点的下一个节点（HashEntry.setNext()）以及将链表写入到数组中（setEntryAt()）都是通过Unsafe的putOrderedObject()方法来实现，这里并未使用具有原子写语义的putObjectVolatile()的原因是：JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后更新到主存，从而保证这些变更对其他线程是可见的。</p>
<h3 id="1-5-rehash"><a href="#1-5-rehash" class="headerlink" title="1.5 rehash"></a>1.5 rehash</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：<br>    private void rehash(HashEntry&lt;K,V&gt; node) {<br>           HashEntry&lt;K,V&gt;[] oldTable = table;<br>           int oldCapacity = oldTable.length;<br>           int newCapacity = oldCapacity &lt;&lt; 1;<br>           threshold = (int)(newCapacity * loadFactor);<br>           HashEntry&lt;K,V&gt;[] newTable =<br>               (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];<br>           int sizeMask = newCapacity - 1;<br>           for (int i = 0; i &lt; oldCapacity ; i++) {<br>               HashEntry&lt;K,V&gt; e = oldTable[i];<br>               if (e != null) {<br>                   HashEntry&lt;K,V&gt; next = e.next;<br>                   int idx = e.hash &amp; sizeMask;<br>                   if (next == null)   //  Single node on list<br>                       newTable[idx] = e;<br>                   else { // Reuse consecutive sequence at same slot<br>                       HashEntry&lt;K,V&gt; lastRun = e;<br>                       int lastIdx = idx;<br>                       for (HashEntry&lt;K,V&gt; last = next;<br>                            last != null;<br>                            last = last.next) {<br>                           int k = last.hash &amp; sizeMask;<br>                           if (k != lastIdx) {<br>                               lastIdx = k;<br>                               lastRun = last;<br>                           }<br>                       }<br>                       newTable[lastIdx] = lastRun;<br>                       // Clone remaining nodes<br>                       for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {<br>                           V v = p.value;<br>                           int h = p.hash;<br>                           int k = h &amp; sizeMask;<br>                           HashEntry&lt;K,V&gt; n = newTable[k];<br>                           newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                       }<br>                   }<br>               }<br>           }<br>           int nodeIndex = node.hash &amp; sizeMask; // add the new node<br>           node.setNext(newTable[nodeIndex]);<br>           newTable[nodeIndex] = node;<br>           table = newTable;<br>       }</p>
<h3 id="1-6-remove"><a href="#1-6-remove" class="headerlink" title="1.6 remove"></a>1.6 remove</h3><p>和put类似，remove在真正获得锁之前，也会对链表进行遍历以提高缓存命中率。</p>
<h3 id="1-7-get与containsKey"><a href="#1-7-get与containsKey" class="headerlink" title="1.7 get与containsKey"></a>1.7 get与containsKey</h3><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p>
<h3 id="1-8-size、containsValue"><a href="#1-8-size、containsValue" class="headerlink" title="1.8 size、containsValue"></a>1.8 size、containsValue</h3><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment（通过Unsafe的getObjectVolatile()以保证原子读语义），获得对应的值以及所有Segment的modcount之和。如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p>
<p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。值得注意的是，加锁过程中要强制创建所有的Segment，否则容易出现其他线程创建Segment并进行put，remove等操作。代码如下：</p>
<pre><code>for(int j =0; j &lt; segments.length; ++j)
     ensureSegment(j).lock();// force creation
</code></pre><p>一般来说，应该避免在多线程环境下使用size和containsValue方法。</p>
<blockquote>
<p>注1：modcount在put, replace, remove以及clear等方法中都会被修改。</p>
</blockquote>
<blockquote>
<p>注2：对于containsValue方法来说，如果在循环过程中发现匹配value的HashEntry，则直接返回true。</p>
</blockquote>
<p>最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，需要特殊处理。在JDK6中，get方法的实现中就有一段对HashEntry.value == null的防御性判断。但Doug Lea也承认实际运行过程中，这种情况似乎不可能发生。</p>
<h2 id="2-JDK8中的实现"><a href="#2-JDK8中的实现" class="headerlink" title="2. JDK8中的实现"></a>2. JDK8中的实现</h2>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/08/01/并发编程之ConcurrentHashMap原理分析/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/08/01/并发编程之ConcurrentHashMap原理分析/" title="并发编程之ConcurrentHashMap原理分析">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/java/">java</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/07/30/为什么String类是不可变的/">
    		为什么String类是不可变的
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-07-30T13:23:41.000Z">2018-07-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/java/" title="java">java</a> / 
    
        <a href="/tags/String/" title="String">String</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。</p>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/07/30/为什么String类是不可变的/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/07/30/为什么String类是不可变的/" title="为什么String类是不可变的">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/微服务/">微服务</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/07/05/Consulu服务注册和发现/">
    		Consulu服务注册和发现
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-07-05T14:53:22.000Z">2018-07-05</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/spring/" title="spring">spring</a> / 
    
        <a href="/tags/consul/" title="consul">consul</a> / 
    
        <a href="/tags/java/" title="java">java</a> / 
    
        <a href="/tags/微服务/" title="微服务">微服务</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Consul（<a href="https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的" target="_blank" rel="noopener">https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的</a> 4 点主要功能：<br>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/07/05/Consulu服务注册和发现/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/07/05/Consulu服务注册和发现/" title="Consulu服务注册和发现">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/中间件/">中间件</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/">
    		ubuntu16.04.3安装RabbitMQ服务器
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-03T11:25:50.000Z">2018-06-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ</a> / 
    
        <a href="/tags/linux/" title="linux">linux</a> / 
    
        <a href="/tags/消息队列/" title="消息队列">消息队列</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构，关于消息队列，市面上有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ这样一些消息队列，但是目前大家用得最多的就是Kafka，<strong>RabbitMQ</strong>，ActiveMQ，但是我们常用的<strong>SpringBoot</strong>不支持ActiveMQ（支持Kafka，RabbitMQ），所以先动手实现在linux上安装RabbitMQ服务器。<br>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/" title="ubuntu16.04.3安装RabbitMQ服务器">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/编程工具/">编程工具</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/03/IntelliJ-idea的快捷键的使用/">
    		IntelliJ IDEA的使用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-03T11:25:50.000Z">2018-06-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/IntelliJ-idea/" title="IntelliJ idea">IntelliJ idea</a> / 
    
        <a href="/tags/jetbrains/" title="jetbrains">jetbrains</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/03/IntelliJ-idea的快捷键的使用/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/03/IntelliJ-idea的快捷键的使用/" title="IntelliJ IDEA的使用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/java/">java</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/03/Hibernate中get()和load()的区别/">
    		Hibernate中get()和load()的区别
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-03T11:25:50.000Z">2018-06-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/java/" title="java">java</a> / 
    
        <a href="/tags/hibernate/" title="hibernate">hibernate</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>最近面试中遇到了关于hibernate中get()和load()两个方法的区别,我在论坛看到了各种论述，我总结了他们的观点以及自己的理解来简单说明下，如果有哪里不对的地方欢迎指正。</p>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/03/Hibernate中get()和load()的区别/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/03/Hibernate中get()和load()的区别/" title="Hibernate中get()和load()的区别">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/github/">github</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/03/hello-world/">
    		Hello World
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-03T11:25:50.000Z">2018-06-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/hexo/" title="hexo">hexo</a> / 
    
        <a href="/tags/博客/" title="博客">博客</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/03/hello-world/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/03/hello-world/" title="Hello World">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/前端/">前端</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/03/ubuntu16.04.3安装rabbitmq服务器/">
    		Bootstrap-table分页删除尾页数据后刷新无数据问题
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-03T11:25:50.000Z">2018-06-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/bootstrap-table/" title="bootstrap-table">bootstrap-table</a> / 
    
        <a href="/tags/js/" title="js">js</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>当我们使用bootstrap-table做表格分页展示的时候，当我们删除最后一页数据的时候，刷新数据发现无数据展示, 针对这种问题，我们有三种解决方式；</p>
</blockquote>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/03/ubuntu16.04.3安装rabbitmq服务器/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/03/ubuntu16.04.3安装rabbitmq服务器/" title="Bootstrap-table分页删除尾页数据后刷新无数据问题">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/版本控制/">版本控制</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/06/02/Git右键没有Git-Bash-Here的解决办法/">
    		Git右键没有Git Bash Here的解决办法
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-06-02T11:25:50.000Z">2018-06-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/git/" title="git">git</a> / 
    
        <a href="/tags/版本控制/" title="版本控制">版本控制</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>大家经常会遇到的一个问题，大家在安装git完成的时候，一般用鼠标右键就可以看到Git Bash Here和Git Gui这两个选项，但是有时候安装git后并没有两个选项，这里我们将要介绍如何配置Git Bash Here这个命令。</p>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/06/02/Git右键没有Git-Bash-Here的解决办法/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/06/02/Git右键没有Git-Bash-Here的解决办法/" title="Git右键没有Git Bash Here的解决办法">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章 -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/java/">java</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/whd-mtt.github.io/2018/05/03/注解的原理和应用/">
    		注解的原理和应用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        whd-mtt 发表于
        <time datetime="2018-05-03T11:25:50.000Z">2018-05-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/java/" title="java">java</a> / 
    
        <a href="/tags/annotation/" title="annotation">annotation</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p>
            
            <p class="more">
                <a href="/whd-mtt.github.io/2018/05/03/注解的原理和应用/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="whd-mtt.github.io/2018/05/03/注解的原理和应用/" title="注解的原理和应用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/中间件/">中间件</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/微服务/">微服务</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/版本控制/">版本控制</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/编程工具/">编程工具</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/java/">java</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/github/">github</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/前端/">前端</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/并发编程/">并发编程</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ (1)</a>
  
    <a class="tag-item" href="/tags/linux/" title="linux">linux (1)</a>
  
    <a class="tag-item" href="/tags/消息队列/" title="消息队列">消息队列 (1)</a>
  
    <a class="tag-item" href="/tags/spring/" title="spring">spring (1)</a>
  
    <a class="tag-item" href="/tags/consul/" title="consul">consul (1)</a>
  
    <a class="tag-item" href="/tags/java/" title="java">java (5)</a>
  
    <a class="tag-item" href="/tags/微服务/" title="微服务">微服务 (1)</a>
  
    <a class="tag-item" href="/tags/git/" title="git">git (1)</a>
  
    <a class="tag-item" href="/tags/版本控制/" title="版本控制">版本控制 (1)</a>
  
    <a class="tag-item" href="/tags/IntelliJ-idea/" title="IntelliJ idea">IntelliJ idea (1)</a>
  
    <a class="tag-item" href="/tags/jetbrains/" title="jetbrains">jetbrains (1)</a>
  
    <a class="tag-item" href="/tags/hibernate/" title="hibernate">hibernate (1)</a>
  
    <a class="tag-item" href="/tags/hexo/" title="hexo">hexo (1)</a>
  
    <a class="tag-item" href="/tags/博客/" title="博客">博客 (1)</a>
  
    <a class="tag-item" href="/tags/bootstrap-table/" title="bootstrap-table">bootstrap-table (1)</a>
  
    <a class="tag-item" href="/tags/js/" title="js">js (1)</a>
  
    <a class="tag-item" href="/tags/String/" title="String">String (1)</a>
  
    <a class="tag-item" href="/tags/并发编程/" title="并发编程">并发编程 (1)</a>
  
    <a class="tag-item" href="/tags/数据结构/" title="数据结构">数据结构 (1)</a>
  
    <a class="tag-item" href="/tags/annotation/" title="annotation">annotation (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://blog.sina.com.cn/u/1825875765" target="_blank" title="网络安全博客">Haoren博客</a>
        </li>
    
        <li>
            <a href="http://blog.csdn.net/yeweiouyang" target="_blank" title="技术博客">Maxwell博客</a>
        </li>
    
        <li>
            <a href="http://xuanzh.cc/" target="_blank" title="技术博客">朱旋个人博客</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2018
    

    <a href="/">Whd-mtt Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>