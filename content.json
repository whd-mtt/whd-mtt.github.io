[{"title":"Tomcat性能优化","date":"2019-05-10T16:33:46.000Z","path":"2019/05/11/Tomcat性能优化/","content":"<h3 id=\"1-What-is-Tomcat\"><a href=\"#1-What-is-Tomcat\" class=\"headerlink\" title=\"1 What is Tomcat\"></a>1 What is Tomcat</h3><p>The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer<br>Pages, Java Expression Language and Java WebSocket technologies.<br><a id=\"more\"></a></p>\n<h3 id=\"2-Version-choose-and-reason\"><a href=\"#2-Version-choose-and-reason\" class=\"headerlink\" title=\"2 Version choose and reason\"></a>2 Version choose and reason</h3><h4 id=\"2-1-Version-choose\"><a href=\"#2-1-Version-choose\" class=\"headerlink\" title=\"2.1 Version choose\"></a>2.1 Version choose</h4><p>Tomcat版本：Tomcat8.0.11<br>jdk版本：大于等于jdk1.7—&gt;【Download/Which version 】<br>tomcat各个版本下载地址：【Download/Archives 】 各个版本产品和源码</p>\n<h4 id=\"2-2-Reason\"><a href=\"#2-2-Reason\" class=\"headerlink\" title=\"2.2 Reason\"></a>2.2 Reason</h4><p>在tomcat7.0中没有NIO2，在tomcat8.5中没有BIO，而在tomcat8.0中支持的比较丰富<br>可以在源码中验证一下:AbstractEndpoint.bind()—&gt;implementation</p>\n<h3 id=\"3-了解回顾\"><a href=\"#3-了解回顾\" class=\"headerlink\" title=\"3 了解回顾\"></a>3 了解回顾</h3><h4 id=\"3-1-源码需要引入的pom-xml文件\"><a href=\"#3-1-源码需要引入的pom-xml文件\" class=\"headerlink\" title=\"3.1 源码需要引入的pom.xml文件\"></a>3.1 源码需要引入的pom.xml文件</h4><p>在tomcat源码的根目录新建pom.xml文件，将下面这段内容复制到pom.xml文件中<br>The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer<br>Pages, Java Expression Language and Java WebSocket technologies.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class=\"line\">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class=\"line\">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\">&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class=\"line\">&lt;artifactId&gt;Tomcat8.0&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;name&gt;Tomcat8.0&lt;/name&gt;</span><br><span class=\"line\">&lt;version&gt;8.0&lt;/version&gt;</span><br><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">&lt;finalName&gt;Tomcat8.0&lt;/finalName&gt;</span><br><span class=\"line\">&lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span><br><span class=\"line\">&lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;</span><br><span class=\"line\">&lt;resources&gt;</span><br><span class=\"line\">&lt;resource&gt;</span><br><span class=\"line\">&lt;directory&gt;java&lt;/directory&gt;</span><br><span class=\"line\">&lt;/resource&gt;</span><br><span class=\"line\">&lt;/resources&gt;</span><br><span class=\"line\">&lt;testResources&gt;</span><br><span class=\"line\">&lt;testResource&gt;</span><br><span class=\"line\">&lt;directory&gt;test&lt;/directory&gt;</span><br><span class=\"line\">&lt;/testResource&gt;</span><br><span class=\"line\">&lt;/testResources&gt;</span><br><span class=\"line\">&lt;plugins&gt;</span><br><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;version&gt;2.3&lt;/version&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">&lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class=\"line\">&lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">&lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br><span class=\"line\">&lt;/plugin&gt;</span><br><span class=\"line\">&lt;/plugins&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;4.12&lt;/version&gt;</span><br><span class=\"line\">\t&lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.easymock&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;easymock&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;3.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;ant&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;javax.xml&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;ecj&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-tomcat产品目录文件含义\"><a href=\"#3-2-tomcat产品目录文件含义\" class=\"headerlink\" title=\"3.2 tomcat产品目录文件含义\"></a>3.2 tomcat产品目录文件含义</h4><p>（1）bin：主要用来存放命令，.bat是windows下，.sh是Linux下<br>（2）conf：主要用来存放tomcat的一些配置文件<br>（3）lib：存放tomcat依赖的一些jar包<br>（4）logs：存放tomcat在运行时产生的日志文件<br>（5）temp：存放运行时产生的临时文件<br>（6）webapps：存放应用程序<br>（7）work：存放tomcat运行时编译后的文件，比如JSP编译后的文件<br>这块咱们就不详细去说了，因为在Javaweb中都学过，即使忘了一些文件或者文件夹的作用，网上介绍的一大堆</p>\n<h4 id=\"3-3-tomcat额外需知\"><a href=\"#3-3-tomcat额外需知\" class=\"headerlink\" title=\"3.3 tomcat额外需知\"></a>3.3 tomcat额外需知</h4><p>（1）Java语言写的<br>（2）servlet/jsp technologies</p>\n<h3 id=\"4-不妨手写一个mini的Tomcat\"><a href=\"#4-不妨手写一个mini的Tomcat\" class=\"headerlink\" title=\"4 不妨手写一个mini的Tomcat\"></a>4 不妨手写一个mini的Tomcat</h3><p>为什么要手写？既然上述提到了tomcat是java语言写的，又和servlet相关，那就自己设计一个试试，先不管作者的想法如<br>何</p>\n<h4 id=\"4-1-确定tomcat作用\"><a href=\"#4-1-确定tomcat作用\" class=\"headerlink\" title=\"4.1 确定tomcat作用\"></a>4.1 确定tomcat作用</h4><p>web服务器，说白了就是能够让客户端和服务端进行交互，比如客户端想要获取服务端某些资源，服务端可以通过<br>tomcat去进行一些处理并且返回。</p>\n<h4 id=\"4-2-基于Socket进行网络通信\"><a href=\"#4-2-基于Socket进行网络通信\" class=\"headerlink\" title=\"4.2 基于Socket进行网络通信\"></a>4.2 基于Socket进行网络通信</h4><p>实际上就是通过serversocket在服务端监听一个端口，等待客户端的连接，然后能够获取到对应的输入输出流<br><br><br><br>//基于网络编程socket套接字来做<br>class MyTomcat{<br>ServerSocket server=new ServerSocket(8080);<br>Socket socket=server.accept();<br>InputStream in=socket.getInputStream();<br>OutputStream out=socket.getOutputStream();<br>}</p>\n<h4 id=\"4-3-优化\"><a href=\"#4-3-优化\" class=\"headerlink\" title=\"4.3 优化\"></a>4.3 优化</h4><p>发现一个比较靠谱的tomcat已经被我们写出来了，问题是这个tomcat如果使用起来方便吗？你会发现不方便，因为对应的<br>request和response都放到了tomcat源码的内部，业务人员想要进行开发时，很难获得request对象，从而获得客户端传来的<br>数据，也不能进行很好的返回，怎么办呢？<br>我们发现在JavaEE中有servlet这项技术，比如我们进行登录功能业务代码开发时,写过如下这段代码和配置<br>所以不妨让tomcat也实现servlet规范，这时候手写的tomcat源码就可以做一个改变</p>\n<h4 id=\"4-4-手写版tomcat-servlets-真的可行吗？\"><a href=\"#4-4-手写版tomcat-servlets-真的可行吗？\" class=\"headerlink\" title=\"4.4 手写版tomcat[servlets]真的可行吗？\"></a>4.4 手写版tomcat[servlets]真的可行吗？</h4><p>换句话说：tomcat官方开发者对于用list集合保存项目中的servlets也是这样想的吗？我们可以从几个维度进行一下推测<br>//优化1:将输入输出流封装到对象<br>class MyTomcat{<br>ServerSocket server=new ServerSocket(8080);<br>Socket socket=server.accept();<br>InputStream in=socket.getInputStream();<br>new Request(in);<br>OutputStream out=socket.getOutputStream();<br>new Response(out);<br>}<br>class Request{private String host;private String accept-language;}<br>class Response{}<br>//优化2前奏：<br>class LoginServlet extends HttpServlet{<br>doGet(request,response){}<br>doPost(request,response){}<br>}</p>\n<p><servlet></servlet></p>\n<p><servlet-name>LoginServlet</servlet-name></p>\n<p><servlet-class>com.gupao.web.servlet.SimpleServlet</servlet-class><br></p>\n<p><servlet-mapping></servlet-mapping></p>\n<p><servlet-name>LoginServlet</servlet-name></p>\n<p><url-pattern>/login</url-pattern><br><br>//优化2：<br>class MyTomcat{<br>List list=new ArrayList();<br>ServerSocket server=new ServerSocket(8080);<br>Socket socket=server.accept();<br>//也就是这个地方不是直接处理request和response<br>//而是处理一个个servlets<br>list.add(servlets);<br>}<br>4.4.1 servlet之业务代码<br>业务代码中关于servlet想必大家都配置过，或者用注解的方式，原本开发web应用就采用的是这样的方式。你的<br>controller中有很多自己写的servlet，都继承了HttpServlet类，然后web.xml文件中配置过所有的servlets，也就<br>是mapping映射，这个很简单。<br>4.4.2 servlet之产品角度<br>如果apache提供的tomcat也这么做了，势必也要跟servlet规范有关系，也就是要依赖servlet的jar包，我们来看一<br>下在tomcat产品的bin文件夹之下有没有servlet.jar，发现有。<br>4.4.3 servlet之源码角度<br>最后我们如果能够在tomcat源码中找到载入servlets的依据，就更加能说明问题了<br>于是我们在idea中的tomcat8.0源码，关键是到哪里找呢？总得有个入口吧？源码中除了能够看到各种Java类型的<br>文件之外，一脸懵逼，怎么办？<br>不妨先跳出来想想，如果我们是tomcat源码的设计者，也就是上述手写的代码，我们怎么将业务代码中的servlets<br>加载到源码中？我觉得可以分为两步<br>（1）加载web项目中的web.xml文件，解析这个文件中的servlet标签，将其变成java中的对象<br>（2）在源码中用集合保存<br>注意第（1）步，为什么是加载web.xml文件呢？因为要想加载servlets，一定是以web项目为单位的，而一个web项目中有多<br>少个servlet类，是会配置在web.xml文件中的。<br>寻找和验证<br>加载和解析web.xml文件<br>加载：ContextConfig.webConfig()—&gt;getContextWebXmlSource()—&gt;Constants.ApplicationWebXml<br>解析：ContextConfig.webConfig()—&gt;configureContext(webXml)—&gt;context.createWrapper()<br>将servlets加载到list集合中<br>StandardContext.loadOnStartup(Container children[])—&gt;list.add(wrapper)<br>4.4.4 加载servlets的疑惑<br>怎么知道上面找的过程的？<br>我们会发现上面加载web.xml文件和添加servlets都和Context有点关系，因为都有这个单词，那这个Context大家<br>眼熟吗？其实我们见过，比如你把web项目想要供外界访问时，你会添加web项目到webapps目录，这是tomcat<br>的规定，除此之外，还可以在conf/server.xml文件中配置Context标签。<br>按照经验之谈，一般框架的设计者都会提供一两个核心配置文件给我们，比如server.xml就是tomcat提供给我们的，而这些<br>文件中的标签属性最终会对应到源码的类和属性<br>4.5 手写版tomcat[监听端口]可行吗？<br>换句话说：tomcat官方开发者对于监听端口也是这么设计的吗<br>其实我们手写的tomcat这块有两个核心：第一是监听端口，第二是添加servlets，上面解决了添加servlets。<br>接下来显然我们有必要验证一下监听端口tomcat也是这么做的吗？<br>4.5.1 监听端口之画图<br>上述的课堂中呈现出来的最好只有MyTomcat和Connector这块，其他先不管<br>在tomcat这块左边一定会监听在某个端口，等待客户端的连接，不然所有的操作都没办法进行交互<br>4.5.2 监听端口之源码角度<br>Connector.initInternal()-&gt;protocolHandler.init()-&gt;AbstractProtocol.init()-&gt;endpoint.init()-&gt;bind()-</p>\n<blockquote>\n<p>Apr,JIo,NIO,NIO2-&gt;JIo即Socket实现方式<br>4.5.3 监听端口的疑惑<br>为什么知道找Connector?<br>再次回到conf/web.xml文件，发现有一个Connector标签，而且还可以配置port端口，我们能够联想到监听端口，<br>按照配置文件到源码类的经验，源码中一定会有这样一个Connector类用于端口的监听。<br>4.6 完善自己的tomcat架构图<br>4.7 推导出tomcat架构图<br>conclusion：架构图<--->server.xml<--->源码 三者有一一对应的关系<br>5 折腾Tomcat架构和源码<br>5.1 认识强化主要组件的含义<br>官网:Documentation/Tomcat8.0/Apache Tomcat Development/Architecture/Overview<br>Server<br>Service<br>Engine<br>In the Tomcat world, a Server represents the whole container. Tomcat provides a default<br>implementation of the Server interface which is rarely customized by users.<br>A Service is an intermediate component which lives inside a Server and ties one or more<br>Connectors to exactly one Engine. The Service element is rarely customized by users, as the<br>default implementation is simple and sufficient: Service interface.Engine<br>Host<br>Connector<br>Context<br>5.2 它们是如何协同工作的？<br>换句话说：之前找了两个点，监听端口，加载servlets的调用过程是如何的？<br>比如bind(),loadOnstartup()到底谁来调用？<br>此时大家还是要回归到最初的流程，客户端发起请求到得到响应来看。<br>客户端角度：发起请求，最终得到响应<br>tomcat代码角度：虽然是要监听端口和添加servlets进来，但是肯定有一个主函数，从主函数开始调用<br>说白了，如果我是源码设计者，既然架构图我都了解了，肯定是要把这些组件初始化出来，然后让它们一起工作，<br>也就是：<br>初始化一个个组件<br>利用这些组件进行相应的操作<br>5.2.1 寻找源码开始的地方<br>An Engine represents request processing pipeline for a specific Service. As a Service may<br>have multiple Connectors, the Engine receives and processes all requests from these<br>connectors, handing the response back to the appropriate connector for transmission to the<br>client. The Engine interface may be implemented to supply custom Engines, though this is<br>uncommon.<br>Note that the Engine may be used for Tomcat server clustering via the jvmRoute parameter.<br>Read the Clustering documentation for more information.<br>A Host is an association of a network name, e.g. <a href=\"http://www.yourcompany.com\" target=\"_blank\" rel=\"noopener\">www.yourcompany.com</a>, to the Tomcat server.<br>An Engine may contain multiple hosts, and the Host element also supports network aliases<br>such as yourcompany.com and abc.yourcompany.com. Users rarely create custom Hosts because<br>the StandardHost implementation provides significant additional functionality.<br>A Connector handles communications with the client. There are multiple connectors available<br>with Tomcat. These include the HTTP connector which is used for most HTTP traffic,<br>especially when running Tomcat as a standalone server, and the AJP connector which<br>implements the AJP protocol used when connecting Tomcat to a web server such as Apache<br>HTTPD server. Creating a customized connector is a significant effort.<br>A Context represents a web application. A Host may contain multiple contexts, each with a<br>unique path. The Context interface may be implemented to create custom Contexts, but this<br>is rarely the case because the StandardContext provides significant additional<br>functionality.<br>一定有一个类，这个类中有main函数开始，这样才能有一款java源码到产品，一贯的作风。<br>感性的认知： BootStrap -&gt;main()-&gt;根据脚本命令-&gt;startd<br>daemon.load() 加载<br>daemon.start() 启动<br>果然被我们找到了，先加载再启动，那就继续看咯<br>5.2.2 加载:daemon.load()的过程<br>Bootstrap.main()-&gt;Bootstrap.load()-&gt;Catalina.load()-&gt;初始化的依据是什么？考虑coder的设计server.xml<br>-&gt;Lifecycle.init()-&gt;LifecycleBase.init()-&gt;LifecycleBase.initInternal()-&gt;StandardServer.initInternal()<br>-&gt;services[i].init()-&gt;StandardService.initInternal()-&gt;executor.init()/ connector.init()<br>-&gt;LifecyleBase.initInternal()-&gt;Connector.initInternal()-&gt;protocolHandler.init()-&gt;AbstractProtocol.init()<br>-&gt;endpoint.init()-&gt;bind()-&gt;Apr,JIo,NIO,NIO2<br>conclusion:请求目前没有来，只是内部的初始化工作<br>5.2.3 启动:daemon.start()的过程<br>Bootstrap.start()-&gt;Catalina.start()-&gt;getServer.start()-&gt;LifecycleBase.start()-&gt;LifecycleBase.startInternal()<br>-&gt;StandardServer.startInternal()-&gt;services[i].start()-&gt;StandardService.startInternal()<br>-&gt; container.start()[查看一下Container接口] /executors.init()/connectors.start()-&gt;engine.start()-<br>StandardEngine.startInternal()<br>查看一下StandardEngine类关系结构图，发现ContainerBase是它的爸爸，而这个爸爸有多少孩子呢？<br>-&gt;super[ContainerBase].startInternal()-&gt;代码呈现<br>关注到new StartChild(children[i])—&gt;child.start()，也就是会调用Engine子容器的start方法，那子容器是什么呢？<br>Host，child.start-&gt;LifecycleBase.start()-&gt;startInternal()-&gt;StandardHost.startInternal()<br>Host将一个个web项目加载进来<br>StandardHost.startInternal()-&gt;ContainerBase.startInternal()-&gt;最后threadStart()<br>-&gt;new Thread(new ContainerBackgroundProcessor())-&gt; run()[processChildren(ContainerBase.this)]<br>-&gt;container.backgroundProcess()-&gt;ContainerBase.backgroundProcess()<br>-&gt;fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null)-&gt;listener.lifecycleEvent(event)<br>-&gt;interested[i].lifecycleEvent(event)-&gt;监听器HostConfig-&gt;HostConfig.lifecycleEvent(LifecycleEvent event)<br>-&gt;check()-&gt; deployApps()<br>Engine,Host,Context,Wrapper都是它的孩子<br>results.add(startStopExecutor.submit(new StartChild(children[i])))<br>回到StandardHost.startInternal() -&gt;super.startInternal()<br>results.add(startStopExecutor.submit(new StartChild(children[i])));<br>然后又会调用它的子容器-&gt;super.startInternal()-&gt;StandardContext.initInternal()<br>StandardContext.startInternal()解析每个web项目<br>ContextConfig.webConfig()的step9解析到servlets包装成wrapper对象<br>何时调用loadOnstartup()<br>StandardContext.startInternal()-&gt;最终会调用if (!loadOnStartup(findChildren()))<br>5.3 官网验证上述流程<br>5.3.1 Server Startup<br>Documentation/Tomcat8.0/Apache Tomcat Development/Architecture/Server Startup:Server Startup<br>5.3.2 Request Process<br>Documentation/Tomcat8.0/Apache Tomcat Development/Architecture/Request Process:UML sequence<br>diagram<br>6 Tomcat性能优化思路<br>6.1 优化思路过渡<br>上面说了这么多，接下来咱们就来聊聊tomcat的性能优化，那怎么进行优化？哪些方面需要进行优化？先有一个<br>整体的认知。<br>其实还是要回归到问题的本质，一个客户端的连接请求响应的流程，看看这个过程经历了什么，哪些地方能够优<br>化。<br>当然，我要补充的一点是，服务器的CPU、内存、硬盘等对性能有决定性的影响，硬件这块配置越高越好。<br>再次看tomcat architecture ：<br>// Deploy XML descriptors from configBase<br>deployDescriptors(configBase, configBase.list());<br>// Deploy WARs<br>deployWARs(appBase, filteredAppPaths);<br>// Deploy expanded folders<br>deployDirectories(appBase, filteredAppPaths);<br>fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null)-&gt;listener.lifecycleEvent(event)<br>interested[i].lifecycleEvent(event)-&gt;[找实现]ContextConfig.lifecycleEvent(LifecycleEvent event)-<br>configureStart()-&gt;webConfig()-&gt;解析每个web项目的xml文件了-&gt;getContextWebXmlSource()-<br>Constants.ApplicationWebXml<br>发现客户端的连接请求会和Connector打交道，对于Connector可以进行选择，比如Http Connector，A JP<br>Connector。<br>整体介绍:Documentation/Tomcat8.0/User Guide/21)Connectors链接<br>详细介绍:Documentation/Tomcat8.0/Reference/Configuration/Connectors链接<br>Executor<br>介绍:Documentation/Tomcat8.0/Reference/Configuration/Executors链接<br>Context<br>介绍:Documentation/Tomcat8.0/Reference/Configuration/Containers/Context链接<br>Context中加载web.xml文件时的源码<br>处理一些过滤器，全局servlet，session等等这些有一个全局的web.xml文件，在conf目录下，源码中会将两<br>者进行合并处理。<br>conclusion:要想改变上面这些内容，适当进行调整，咱们去修改tomcat源码显然不合适，那怎么修改呢？tomcat给我们提<br>供了可以进行定制自己组建的相关配置文件，比如说conf目录下的server.xml和web.xml文件,也就是说我们可以站在修改配<br>置文件的角度进行性能优化<br>继续思考tomcat性能优化思路<br>既然tomcat是Java写的，最终这些代码是会跑到jvm虚拟机中的，也就是说jvm的一些优化思路也可以在tomcat中<br>进行落实。<br>6.2 配置优化<br>由前面的分析可以定位目前两个重要的配置文件conf/server.xml conf/web.xml<br>6.2.1 conf/server.xml核心组件<br>Server<br>官网描述:Server interface which is rarely customized by users. 【pass】<br>Service<br>官网描述:The Service element is rarely customized by users. 【pass】<br>Connector<br>官网描述:Creating a customized connector is a significant effort. 【need 】<br>Engine<br>官网描述:The Engine interface may be implemented to supply custom Engines, though this is uncommon.<br>【pass】<br>Host<br>官网描述:Users rarely create custom Hosts because the StandardHost implementation provides significant<br>additional functionality. 【pass】<br>Context<br>官网描述:The Context interface may be implemented to create custom Contexts, but this is rarely the case<br>because the StandardContext provides significant additional functionality. 【maybe 】<br>Context既然代表的是web应用，是和我们比较接近的，这块我们考虑对其适当的优化<br>conclusion:Connector and Context<br>6.2.2 conf/server.xml非核心组件<br>官网:Documentation/Reference/Configuration/Nested Components/xxx<br>Listener<br>Global Resources<br>The GlobalNamingResources element defines the global JNDI resources for the [Server]<br>(<a href=\"https://tomcat.apache.org/tomcat-8.0-doc/config/server.html\" target=\"_blank\" rel=\"noopener\">https://tomcat.apache.org/tomcat-8.0-doc/config/server.html</a>)<br>Valve<br>功能类似于过滤器Filter<br>Realm<br>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。</---></---></p>\n</blockquote>\n<p><listener classname=\"org.apache.catalina.core.AprLifecycleListener\" sslengine=\"on\"><br><!--监听内存溢出--></listener></p>\n<p><listener classname=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\"></listener></p>\n<p><listener classname=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\"></listener></p>\n<p><listener classname=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\"><br>GlobalNamingResources元素定义了全局资源，通过配置可以看出，该配置是通过读取$TOMCAT_HOME/ conf/tomcatusers.<br>xml实现的。</listener></p>\n<p><globalnamingresources></globalnamingresources></p>\n<p><resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\"><br></resource></p>\n<p><valve classname=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &quot;%r&quot; %s %b\"><br>A Realm element represents a “database” of usernames, passwords, and roles (similar to Unix groups)<br>assigned to those users.<br>6.2.3 conf/web.xml<br>全局的web.xml文件有些标签用不到的，可以删除掉，具体后面会说。<br>6.3 JVM优化<br>6.3.1 内存设置<br>为了防止内存不够用，显然可以设置一下内存的大小<br>6.3.2 GC算法<br>选择合适的GC算法，其实内存大小的设置也会影响GC<br>6.4 小结<br>减少相关配置-&gt;查看日志tomcat启动时间<br>项目方法:Connector-&gt;BIO/NIO/APR-&gt;压测某个项目的方法观察Throughout<br>JVM :jconsole,gceasy.io,jvisual<br>7 相关环境准备<br>7.1 windows<br>jdk1.8<br>maven<br>git<br>idea<br>tomcat8.0<br>Realm，可以把它理解成“域”；Realm提供了一种用户密码与web应用的映射关系，从而达到角色安全管理的作用。在本<br>例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配<br>置</valve></p>\n<p><realm classname=\"org.apache.catalina.realm.LockOutRealm\"><br><!-- This Realm uses the UserDatabase configured in the global JNDI\nresources under the key \"UserDatabase\". Any edits\nthat are performed against this UserDatabase are immediately\navailable for use by the Realm. --></realm></p>\n<p><realm classname=\"org.apache.catalina.realm.UserDatabaseRealm\" resourcename=\"UserDatabase\"><br></realm><br>Xshell<br>jmeter<br>用于本地压测观察<br>ftp/rzsz<br>用于本地和远端文件交互<br>7.2 centos7<br>本地搭建或者购买阿里云服务器安装centos系统<br>jdk1.8<br>本地上传到生产环境,解压配置环境变量<br>maven<br>本地上传到生产环境,解压配置环境变量<br>tomcat8.0<br>本地上传到生产环境,解压配置环境变量<br>如果tomcat启动慢，则catalina.sh的JAVA_OPTS加入-Djava.security.egd=file:/dev/./urandom<br>7.3 一个web项目<br>7.4 JVisualVM监控java进程<br>（1）命令行输入jvisualvm<br>（2）选择本地的java进程【本地无需任何设置，直接连接即可】<br>（3）监控远程tomcat<br>输入远程ip地址，修改远端的catalina.sh文件，添加如下内容<br>这是我上课用的账号和密码，只有一个月有效期<br>ip地址:39.98.168.189<br>账户:root<br>密码:AAbb1234<br>项目名称:gp/index.html<br>项目介绍:<br>其实就是一个静态页面，接下来就是对这个页面进行压测<br>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote<br>-Djava.rmi.server.hostname=39.98.168.189 -Dcom.sun.management.jmxremote.port=8998<br>-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true<br>-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password<br>-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access”<br>然后在jvisualvm中添加远程连接，JMX类型<br>采坑指南<br>查看hostname -i，修改/etc/hosts文件公网ip地址指向查询到的地址<br>lsof -i tcp:8998 得到PID<br>然后netstat -antup | grep PID 得到几个端口号，在阿里云安全组中添加相应端口<br>上述修改之后要重启远端的tomcat<br>添加JMX Connection，注意端口写8999<br>防火墙要记得添加对应的策略<br>在conf文件中添加两个文件jmxremote.access和jmxremote.password，内容分别为<br>授予文件相应权限: chmod 600 <em>jmxremot</em><br>7.5 tomcat-manager/probe<br>如果不想用jvisualvm来监控tomcat线程内存的信息，也可以选择tomcat自带的tomcat-manager或者probe来监<br>控，只是有些功能没有那么完善。<br>7.6 课程中常用命令<br>启动停止tomcat,来到tomcat的bin文件夹<br>启动: ./startup.sh<br>停止:./shutdown.sh<br>查看tomcat启动日志<br>cat ../logs/catalina.out<br>tail -f ../logs/catalina.out 相当于监控该日志文件<br>解压<br>tar -zxvf xxx<br>查看进程及端口号<br>查看进程: ps -ef | grep tomcat/java<br>端口号:lsof -i tcp:8080<br>杀掉进程<br>kill PID<br>查看jvm内所有线程<br>guest readonly<br>manager readwrite<br>guest guest<br>manager manager<br>jstack PID<br>官网线程状态描述<br>maven打包<br>mvn clean package<br>mvn clean package -Dmaven.test.skip<br>jinfo查看jvm某个参数是否启用<br>jinfo -flag UseParallelGC PID<br>jinfo -flag MaxHeapSize PID 查看最大内存<br>jinfo -flag UseG1GC PID 查看垃圾回收器<br>jinfo -flags PID 查看曾经赋过值的一些参数<br>查看java进程<br>jps -l<br>查看jvm统计信息<br>jstat -class/-gc PID 1000 10<br>导出内存信息<br>8 Tomcat性能优化<br>写的不错的一篇文章链接:资料<br>8.1 配置优化<br>8.1.1 减少web.xml/server.xml中标签<br>最终观察tomcat启动日志[时间/内容]，线程开销，内存大小，GC等<br>DefaultServlet<br>官网:User Guide-&gt;Default Servlet<br>The default servlet is the servlet which serves static resources as well as serves the directory listings (if<br>directory listings are enabled).<br>jmap -dump:format=b,file=heap.hprof pid<br>jmap -heap pid 打印出堆内存相关的信息</p>\n<p><servlet></servlet></p>\n<p><servlet-name>default</servlet-name></p>\n<p><servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class></p>\n<p><init-param></init-param></p>\n<p><param-name>debug</param-name></p>\n<p><param-value>0</param-value><br></p>\n<p><init-param><br>JspServlet<br>welcome-list-file<br>mime-mapping移除响应的内容<br>支持的下载打开类型</init-param></p>\n<p><param-name>listings</param-name></p>\n<p><param-value>false</param-value><br></p>\n<p><load-on-startup>1</load-on-startup><br></p>\n<p><servlet-mapping></servlet-mapping></p>\n<p><servlet-name>default</servlet-name></p>\n<p><url-pattern>/</url-pattern><br></p>\n<p><servlet></servlet></p>\n<p><servlet-name>jsp</servlet-name></p>\n<p><servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class></p>\n<p><init-param></init-param></p>\n<p><param-name>fork</param-name></p>\n<p><param-value>false</param-value><br></p>\n<p><init-param></init-param></p>\n<p><param-name>xpoweredBy</param-name></p>\n<p><param-value>false</param-value><br></p>\n<p><load-on-startup>3</load-on-startup><br></p>\n<p><servlet-mapping></servlet-mapping></p>\n<p><servlet-name>jsp</servlet-name></p>\n<p><url-pattern>*.jsp</url-pattern></p>\n<p><url-pattern>*.jspx</url-pattern><br></p>\n<p><welcome-file-list></welcome-file-list></p>\n<p><welcome-file>index.html</welcome-file></p>\n<p><welcome-file>index.htm</welcome-file></p>\n<p><welcome-file>index.jsp</welcome-file><br><br>session-config<br>默认jsp页面有session，就是在于这个配置<br>8.1.2 调整优化server.xml中标签<br>8.1.2.1 Connector标签<br>protocol属性<br>对于protocol=”HTTP/1.1”，查看源码<br>构造函数<br>setProtocol(protocol)因为配置文件中传入的是HTTP/1.1<br>并且这里没有使用APR，一会我们会演示APR</p>\n<p><mime-mapping></mime-mapping></p>\n<p><extension>123</extension></p>\n<p><mime-type>application/vnd.lotus-1-2-3</mime-type><br></p>\n<p><mime-mapping></mime-mapping></p>\n<p><extension>3dml</extension></p>\n<p><mime-type>text/vnd.in3d.3dml</mime-type><br></p>\n<p><session-config></session-config></p>\n<p><session-timeout>30</session-timeout><br></p>\n<p><connector port=\"8080\" protocol=\"HTTP/1.1\" connectiontimeout=\"20000\" redirectport=\"8443\"><br>public Connector(String protocol) {<br>setProtocol(protocol);<br>}<br>发现这里调用的是Http11NioProtocol，也就是说明tomcat8.0.x中默认使用的是NIO<br>使用同样的方式看tomcat7和tomcat8.5，你会发现tomcat7默认使用的是BIO，tomcat8.5默认使用的是NIO<br>针对BIO和NIO的方式进行压测<br>（1）BIO<br>来到tomcat官网Configuration/HTTP/protocol<br>org.apache.coyote.http11.Http11Protocol - blocking Java connector<br>org.apache.coyote.http11.Http11NioProtocol - non blocking Java NIO connector<br>org.apache.coyote.http11.Http11Nio2Protocol - non blocking Java NIO2 connector<br>org.apache.coyote.http11.Http11AprProtocol - the APR/native connector.<br>使用tomcat7取巧一下，默认是BIO，端口改成7070，将tomcat-optimize复制到tomcat7中<br>（2）NIO<br>tomcat8.0中默认使用的是NIO<br>针对上述BIO和NIO的方式，进行压测，调整并发数，看吞吐量<br>（3）APR<br>【具体查看操作手册/APR安装方式】<br>下载以下内容：<br>apr<br>apr-iconv<br>apr-util<br>并且上传到centos中<br>先安装一些依赖库: yum install apr<em> openssl-devel gcc make<br>安装apr<br>解压apr，cd到源码目录<br>./configure –prefix=/usr/local/apr 指定安装的目录<br>make 编译<br>make install 安装<br>else {<br>if (“HTTP/1.1”.equals(protocol)) {<br>setProtocolHandlerClassName<br>(“org.apache.coyote.http11.Http11NioProtocol”);<br>} else if (“AJP/1.3”.equals(protocol)) {<br>setProtocolHandlerClassName<br>(“org.apache.coyote.ajp.AjpNioProtocol”);<br>} else if (protocol != null) {<br>setProtocolHandlerClassName(protocol);<br>}<br>}<br>安装apr-iconv<br>解压apr-iconv，cd到源码目录<br>./configure –prefix==/usr/local/apr-iconv –with-apr=/usr/local/apr 使用了一下刚才的apr<br>make<br>make install<br>安装依赖包 yum install expat-devel<br>安装apr-util<br>解压apr-util,cd到源码目录<br>./configure –prefix=/usr/local/apr-util –with-apr=/usr/local/apr<br>make<br>make install<br>安装openssl 1.0.2k<br>解压，cd到源码目录<br>./config –prefix=/usr/local/openssl<br>修改Makefile文件，将CFLAG=-DOPENSSL_THREADS修改为CFLAG= -fPIC -DOPENSSL_THREADS<br>make<br>make install<br>来到tomcat的bin目录<br>解压tomcat-native.tar.gz<br>cd tomcat-native-1.x-src/jni/native<br>./configure –with-apr=/usr/local/apr –with-ssl=/usr/local/openssl<br>make<br>make install<br>配置bin/catalina.sh<br>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib<br>export LD_LIBRARY_PATH<br>server.xml中的AprListener需要关闭SSL的方式，值设置为off<br>重新启动tomcat，看日志apr的方式<br>也可以压测看一下效果<br>executor属性<br>最佳线程数公式:((线程等待时间+线程cpu时间)/线程cpu时间) </em> cpu数量<br>设置一些属性<br>官网:<a href=\"https://tomcat.apache.org/tomcat-8.0-doc/config/http.html\" target=\"_blank\" rel=\"noopener\">https://tomcat.apache.org/tomcat-8.0-doc/config/http.html</a><br>The Executor represents a thread pool that can be shared between components in Tomcat.<br>Historically there has been a thread pool per connector created but this allows you to share a<br>thread pool, between (primarily) connector but also other components when those get configured<br>to support executors<br>（1）acceptCount:达到最大连接数之后，等待队列中还能放多少连接，超过即拒绝，配置太大也没有意义<br>The maximum queue length for incoming connection requests when all possible request processing<br>threads are in use. Any requests received when the queue is full will be refused. The default<br>value is 100.<br>（2）maxConnections<br>达到这个值之后，将继续接受连接，但是不处理，能继续接受多少根据acceptCount的值<br>BIO:maxThreads<br>NIO/NIO2:10000 ——— AbstractEndpoint.maxConnections<br>APR:8192<br>The maximum number of connections that the server will accept and process at any given time. When<br>this number has been reached, the server will accept, but not process, one further connection.<br>This additional connection be blocked until the number of connections being processed falls below<br>maxConnections at which point the server will start accepting and processing new connections<br>again. Note that once the limit has been reached, the operating system may still accept<br>connections based on the acceptCount setting. The default value varies by connector type. For BIO<br>the default is the value of maxThreads unless an Executor is used in which case the default will<br>be the value of maxThreads from the executor. For NIO and NIO2 the default is 10000. For<br>APR/native, the default is 8192.<br>Note that for APR/native on Windows, the configured value will be reduced to the highest multiple<br>of 1024 that is less than or equal to maxConnections. This is done for performance reasons.<br>If set to a value of -1, the maxConnections feature is disabled and connections are not counted.<br>（3）maxThreads:最大工作线程数，也就是用来处理request请求的，默认是200，如果自己配了executor，并且<br>和Connector有关联了，则之前默认的200就会被忽略，取决于CPU的配置。监控中就可以看到所有的工作线程是<br>什么状态，通过监控就能知道开启多少个线程合适<br>The maximum number of request processing threads to be created by this Connector, which therefore<br>determines the maximum number of simultaneous requests that can be handled. If not specified,<br>this attribute is set to 200. If an executor is associated with this connector, this attribute is<br>ignored as the connector will execute tasks using the executor rather than an internal thread<br>pool. Note that if an executor is configured any value set for this attribute will be recorded<br>correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.<br>（4）minSpareThreads<br>最小空闲线程数<br>The minimum number of threads always kept running. This includes both active and idle threads. If<br>not specified, the default of 10 is used. If an executor is associated with this connector, this<br>attribute is ignored as the connector will execute tasks using the executor rather than an<br>internal thread pool. Note that if an executor is configured any value set for this attribute<br>will be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is<br>not used.<br>可以实践一下，Connector配合自定义的线程池<br>其实这块最好的方式是结合BIO来看，因为BIO是一个request对应一个线程<br>值太低，并发请求多了之后，多余的则进入等待状态。<br>值太高，启动Tomcat将花费更多的时间。<br>比如可以改成250。<br>enableLookups<br>设置为false<br>删掉A JP的Connector<br>8.1.2.2 Host标签<br>autoDeploy :Tomcat运行时，要用一个线程拿出来进行检查，生产环境之下一定要改成false<br>This flag value indicates if Tomcat should check periodically for new or updated web applications<br>while Tomcat is running. If true, Tomcat periodically checks the appBase and xmlBase directories<br>and deploys any new web applications or context XML descriptors found. Updated web applications<br>or context XML descriptors will trigger a reload of the web application. The flag’s value<br>defaults to true. See Automatic Application Deployment for more information.<br>8.1.2.3 Context标签<br>reloadable:false<br>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下<br>class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。<br>在开发阶段将reloadable属性设为true，有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议<br>在Web应用的发存阶段将reloadable设为false。<br>Set to true if you want Catalina to monitor classes in /WEB-INF/classes/ and /WEB-INF/lib for<br>changes, and automatically reload the web application if a change is detected. This feature is<br>very useful during application development, but it requires significant runtime overhead and is<br>not recommended for use on deployed production applications. That’s why the default setting for<br>this attribute is false. You can use the Manager web application, however, to trigger reloads of<br>deployed applications on demand.</connector></p>\n<p><connector executor=\"tomcatThreadPool\" port=\"8080\" protocol=\"HTTP/1.1\" connectiontimeout=\"20000\" redirectport=\"8443\"></connector></p>\n<p><executor name=\"tomcatThreadPool\" nameprefix=\"catalina-exec-\" maxthreads=\"150\" minsparethreads=\"4\"><br>8.2 JVM优化<br>8.2.1 JVM优化过渡<br>为什么会有JVM这块的优化？因为tomcat是java语言写的，那么对于jvm这块的优化在tomcat中就是适用的。比如<br>修改一些参数，调整内存大小，选择合适的垃圾回收算法等等。<br>现在有个问题，修改JVM参数在哪里修改会对tomcat生效？还是在bin文件夹之下，有一个catalina.sh，找到<br>JAVA_OPTS即可，当然不建议对此文件进行直接修改，一般是在外面新建一个文件，然后引入进来，我们就不这样<br>做了，直接修改bin/catalina.sh 文件。<br>8.2.2 运行时数据区和内存结构<br>既然要对内存的大小做调整设置，你得认知一下jvm这块的内容，这里之前James老师的公开课和VIP课中讲过，当<br>然你没听过也没关系，可以回头听一下，而且后面大白老师也会和大家讲这块的内容。<br>结论:接下来我也站在我的角度和大家做一个简单的分享，这有利于接下来我们tomcat的jvm调优。<br>运行时数据区是一个规范，内存结构是一个实际的实现<br>运行时数据区<br>官网:官网<br>（1）程序计数器The pc Register<br>JVM支持多线程同时执行，每一个线程都有自己的pc register，线程正在执行的方法叫做当前方法。如果是java代<br>码，pc register中存放的就是当前正在执行的指令的地址，如果是c代码，则为空。<br>（2）Java虚拟机栈Java Virtual Machine Stacks<br>Java虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执<br>行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直<br>到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>（3）堆Heap<br>Java堆是Java虚拟机所管理的内存中最大的一块。对是被所有线程共享的一块内存区域，在虚拟机启动时创建。次<br>内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java对可以处于物理上不连续的内存空间中，只要逻辑上市连续的即可。<br>（4）方法区Method Area<br>方法区和Java堆一样，是各个线程共享的内存区域，也是在虚拟机启动时创建。它用于存储已被虚拟机加载的类信<br>息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，<br>但是它却有一个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来。<br>jdk1.8中就是metaspace<br>jdk1.6或者1.7中就是perm space<br>运行时常量池Runtime Constant Pool是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述<br>信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进<br>入方法区的运行时常量池中存放。<br>（5）本地方法栈Native Method Stacks<br>本地方法栈和虚拟机栈锁发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈执行Java方法服务，而本地方<br>法栈则为虚拟机使用到的native方法服务。<br>内存结构<br>上面对运行时数据区描述了很多，其实重点存储数据的是堆和方法区(非堆)，所以我们内存结构的设计也是着重从<br>这两方面展开的。<br>一块是非堆区，一块是堆区。<br>堆区分为两大块，一个是Old区，一个是Young区。<br>Young区分为两大块，一个是Survival区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1<br>S0和S1一样大，也可以叫From和To。<br>在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。<br>8.2.3 垃圾回收算法<br>为什么需要学习垃圾回收算法？<br>Java是做自动内存管理的，自动垃圾回收。<br>如何确定一个对象是否是垃圾，从而确定是否需要回收？<br>（1）引用计数<br>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其<br>引用，它就是垃圾。<br>弊端:AB相互持有引用，导致永远不能被回收。<br>（2）枚举根节点做可达性分析<br>能作为根节点的:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。<br>常量的垃圾回收算法<br>能够确定一个对象是垃圾之后，怎么回收？得要有对应的算法<br>（1）标记清除<br>先标记所有需要回收的对象，然后统一回收。<br>缺点:效率不高，标记和清除两个过程的效率都不高，容易产生碎片，碎片太多会导致提前GC。<br>（2）复制<br>将内存按容量划分为大小相等的两块(S0和S1)，每次只使用其中一块。<br>当这块使用完了，就讲还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次性清除掉【Young区此<br>采用的是复制算法】<br>优缺点:实现简单，运行高效，但是空间利用率低。<br>（3）标记整理<br>标记需要回收的对象，然后让所有存活的对象移动到另外一端，直接清理掉端边界意外的内存。<br>JVM中采用的是分代垃圾回收<br>换句话说，堆中的Old区和Young区采用的垃圾回收算法是不一样的。<br>（1）Young区：复制算法<br>（2）Old区：标记清除或标记整理<br>对象在被分配之后，可能声明周期比较短，Young区复制效率比较高。<br>Old区对象存活时间比较长，复制来复制去没必要，不如做个标记。<br>对象分配方式<br>对象优先分配在Eden区<br>大对象直接进入老年代，多大的对象称为大对象？可以通过JVM参数指定 -XX:PretenureSizeThreshold<br>长期存活对象进入老年代<br>8.2.4 垃圾收集器<br>串行收集器Serial:Serial、Serial Old<br>一个线程跑，停止，启动垃圾回收线程，回收完成，继续执行刚才暂停的线程。适用于内存比较小的嵌入式<br>设备中。<br>并行收集器Parallel:Parallel Scavenge、Parallel Old，吞吐量优先<br>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态，适合科学计算、后台处理等弱交互场景<br>并发收集器Concurrent:CMS、G1，停顿时间优先<br>用户线程和垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾收集线程在执行的时候不会停<br>顿用户程序的运行。适合于对相应时间有要求的场景，比如Web。<br>吞吐量和停顿时间解释<br>吞吐量:花在垃圾收集的时间和花在应用程序时间的占比<br>停顿时间:垃圾收集器做垃圾回收终端应用执行的时间<br>小结: 评价一个垃圾回收器的好坏，其实调优的时候就是在观察者两个变量<br>开启垃圾收集器<br>Young区和Old区适用的垃圾回收器<br>jdk1.8中比较推荐使用G1垃圾回收器，性能比较高。<br>常用的G1 Collector<br>jdk1.7开始使用，jdk1.8非常成熟，jdk1.9默认的垃圾收集器<br>要求:&gt;=6GB,停顿时间小于0.5秒<br>适用于新老生代<br>（1）串行： -XX：+UseSerialGC -XX：+UseSerialOldGC 新老生代<br>（2）并行(吞吐量优先)：<br>-XX：+UseParallelGC<br>-XX：+UseParallelOldGC<br>（3）并发收集器(响应时间优先)<br>CMS： -XX：+UseConcMarkSweepGC<br>G1： -XX：+UseG1GC<br>是否需要用G1的判断依据<br>（1）50%以上的堆被存活对象占用<br>（2）对象分配和晋升的速度变化非常大<br>（3）垃圾回收时间比较长<br>如何选择合适的垃圾回收器<br>（1）优先调整堆的大小让服务器自己来选择<br>（2）如果内存小于100M，使用串行收集器<br>（3）如果是单核，并且没有停顿时间要求，使用串行或JVM自己选<br>（4）如果允许停顿时间超过1秒，选择并行或JVM自己选<br>（5）如果响应时间最重要，并且不能超过1秒，使用并发收集器<br>8.2.5 两款GC日志分析工具<br>评价一个垃圾回收器的好坏：吞吐量和停顿时间<br>要想分析，得把GC日志打印出来才行，可以在tomcat中catalina.sh JAVA_OPTS配置相关参数<br>XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -<br>Xloggc:$CATALINA_HOME/logs/gc.log<br>然后重启tomcat，下载下来看看内容<br>在线:<a href=\"http://gceasy.io\" target=\"_blank\" rel=\"noopener\">http://gceasy.io</a><br>上述日志直接看比较费力，不妨借助工具，把gc.log下载到本地，然后上传到gceasy.io<br>可以比较不同的垃圾回收器的日志情况<br>GCViewer<br>8.2.6 内存模型和GC联系<br>Minor GC:新生代<br>Major GC:老年代<br>Full GC:新生代+老年代<br>一个对象的一辈子-概要<br>一般情况下,新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后,如果仍然存活,<br>将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC,年龄就会增加1岁,当它的年龄增加到一定程度时,就<br>会被移动到年老代中。<br>一个对象的一辈子-理论<br>在GC开始的时候,对象只会存在于Eden区和名为“From”的Survivor区,Survivor区“To”是空的。紧接着进行GC,Eden区中<br>所有存活的对象都会被复制到“To”,而在“From”区中,仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年<br>龄阈值,可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中,没有达到阈值的对象会被复制<br>到“To”区域。经过这次GC后,Eden区和From区已经被清空。这个时候,“From”和“To”会交换他们的角色,也就是新<br>的“To”就是上次GC前的“From”,新的“From”就是上次GC前的“To”。不管怎样,都会保证名为To的Survivor区域是空的。<br>Minor GC会一直重复这样的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。<br>一个对象的一辈子-案例<br>我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有<br>一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在<br>Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯了。<br>于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每<br>次GC加一岁),然后被回收。<br>为什么会有Survival区<br>如果没有Survivor,Eden区每进行一次Minor GC,存活的对象就会被送到老年代。老年代很快被填满,触发Major GC(因为<br>Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。老年代的内存空间远大于新生代,进行一次Full GC消耗的<br>时间比Minor GC长得多。你也许会问,执行时间长有什么坏处?频发的Full GC消耗的时间是非常可观的,这一点会影响大<br>型程序的执行和响应速度,更不要说某些连接会因为超时发生连接错误了。<br>增加老年代空间 更多存活对象才能填满老年代。降低Full GC频率 随着老年代空间加大,一旦发生Full GC,<br>执行所需要的时间更长<br>减少老年代空间 Full GC所需时间减少 老年代很快被存活对象填满,Full GC频率增加<br>Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次<br>Minor GC还能在新生代中存活的对象,才会被送到老年代。<br>为什么会有两个Survival区<br>设置两个Survivor区最大的好处就是解决了碎片化,下面我们来分析一下。<br>为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个survivor区,我们来模拟<br>一下流程:<br>刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循<br>环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的<br>存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。<br>永远有一个survivor space是空的,另一个非空的survivor space无碎片。<br>8.2.7 JVM常见参数<br>无论是设置内存大小还是选用不同的GC Collector都可以通过JVM参数的形式，所以我们有必要了解一下JVM参数<br>相关的内容。<br>标准参数<br>-help<br>-server -client<br>-version -showversion<br>-cp -classpath<br>X参数<br>非标准参数，也就是在jvm各个版本中可能会变<br>-Xint 解释执行<br>-Xcomp 第一次使用就编译成本地代码<br>-Xmixed 混合模式，JVM自己来决定是否编译成本地代码<br>XX参数<br>特殊参数<br>-Xmx -Xms 设置最大最小内存的<br>不是X参数，而是XX参数<br>-Xms等价于-XX:InitialHeapSize<br>-Xmx等价于-XX:MaxHeapSize<br>-Xss等价于-XX:ThreadStackSize<br>查看JVM运行时参数<br>得先知道当前的值是什么，然后才能设置调优<br>=表示默认值<br>:=表示被用户或JVM修改后的值<br>查看PID: jps -l，专门用来查看java进程的<br>jinfo 查看已经运行的jvm里面的参数值<br>jinfo -flag MaxHeapSize PID 查看最大内存<br>jinfo -flag UseG1GC PID 查看垃圾回收器<br>jinfo -flags PID 查看曾经赋过值的一些参数<br>jstat查看JVM统计信息<br>（1）类装载<br>jstat -class PID 1000 10<br>PID进程ID，1000每个一秒钟，10输出10次<br>（2）垃圾收集<br>jstat -gc PID 1000 10<br>平时用的最多的参数类型<br>非标准化参数，相对不稳定，主要用于JVM调优和Debug<br>a.Boolean类型<br>格式：-XX:[+-]<name> 表示启用或者禁用name属性<br>比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器<br>-XX:+UseG1GC 表示启用CMS类型的垃圾回收器<br>b.非Boolean类型<br>格式：-XX<name>=<value>表示name属性的值是value<br>比如：-XX:MaxGCPauseMillis=500<br>S0C S1C S0U S1U EC EU OC OU GCT<br>2560.0 2560.0 0.0 2556.0 30720.0 29499.0 40960.0 11559.8 16512.0<br>MC MU CCSC CCSU YGC YGCT FGC FGCT<br>15968.7 1920.0 1795.4 3 0.038 0 0.000 0.038<br>8.2.8 内存溢出和优化<br>内存不够用主要分为两个方面：堆和非堆<br>所以这时候就要去手动设置堆或者非堆的大小，然后程序中不停使用相对应的区域，等待内存溢出。<br>关键是内存溢出之后，怎么得到溢出信息进行分析，有两种做法<br>参数设置自动<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=./<br>jmap手动<br>查看当前进程id PID<br>jmap -dump:format=b,file=heap.hprof PID<br>jmap -heap PID 打印出堆内存相关的信息<br>当内存信息打印出来之后，发现看不懂，怎么办呢？得要有工具帮助我们看这块的信息，比如MAT<br>小结:这块可以适当增加内存的大小，这样防止内存溢出，减少垃圾回收的频率<br>8.2.9 GC调优<br>（1）查看目前JVM使用的垃圾回收器<br>[root@pretty ~]# jinfo -flag UseParallelGC 6925<br>-XX:+UseParallelGC —&gt;发现使用了ParallelGC<br>[root@pretty ~]# jinfo -flag UseG1GC 6925<br>-XX:-UseG1GC —&gt;发现没有使用G1GC<br>（2）将垃圾回收器修改为G1<br>-XX:+UseG1GC<br>[root@pretty ~]# jinfo -flag UseG1GC 7158<br>-XX:+UseG1GC<br>（3）打印出日志详情信息和日志输出目录文件<br>PrintGCDetails:打印日志详情信息<br>PrintGCTimeStamps:输出GC的时间戳(以基准时间的形式)<br>（4）将日志用工具来分析，看相应的参数<br>8.2.10 JVM调优小结<br>内存大小设置——&gt;dump出日志 使用MAT工具分析<br>垃圾收集器选择———&gt;dump出GC日志 gceasy或者GCViewer<br>8.3 其他优化<br>Connector<br>配置压缩属性compression=”500”，文件大于500bytes才会压缩<br>数据库优化<br>减少对数据库访问等待的时间，可以从数据库的层面进行优化，或者加缓存等等各种方案。<br>开启浏览器缓存，nginx静态资源部署<br>9 嵌入式Tomcat主类寻找<br>9.1 maven<br>寻找:Tomcat7RunnerCli类，寻找main函数<br>9.2 springboot<br>org.springframework.boot.context.embedded.tomcat.EmbeddedServletContainerCustomizer<br>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -<br>Xloggc:$CATALINA_HOME/logs/g1gc.log</value></name></name></executor></p>\n<p><dependency></dependency></p>\n<p><groupid>org.apache.tomcat.maven</groupid></p>\n<p><artifactid>tomcat7-maven-plugin</artifactid></p>\n<p><version>2.0</version><br><br>// 相当于 new TomcatContextCustomizer(){}<br>factory.addContextCustomizers((context) -&gt; { // Lambda<br>if (context instanceof StandardContext) {<br>StandardContext standardContext = (StandardContext) context;<br>// standardContext.setDefaultWebXml(); // 设置<br>}<br>});</p>\n","comments":true,"categories":[{"name":"性能优化","slug":"性能优化","permalink":"itratel.github.io/categories/性能优化/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"itratel.github.io/tags/Tomcat/"}]},{"title":"四种引用的理解","date":"2018-12-21T16:08:36.000Z","path":"2018/12/22/四种引用的理解/","content":"","comments":true,"categories":[],"tags":[]},{"title":"受检查异常和非受检查异常的区别","date":"2018-12-21T15:36:33.000Z","path":"2018/12/21/受检查异常和非受检查异常的区别/","content":"","comments":true,"categories":[],"tags":[]},{"title":"Docker命令整理","date":"2018-10-18T12:22:03.000Z","path":"2018/10/18/Docker命令整理/","content":"","comments":true,"categories":[],"tags":[]},{"title":"并发编程之ConcurrentHashMap原理分析","date":"2018-08-01T13:03:20.000Z","path":"2018/08/01/并发编程之ConcurrentHashMap原理分析/","content":"<p>&emsp;&emsp;在并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable和Collections.synchronizedMap()，前者在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS和锁分段的技术来减少锁竞争对于性能的影响，接下来我将分别阐述ConcurrentHashMap在JDK6/7/8分别是如何实现的。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-JDK1-6和1-7中的实现\"><a href=\"#1-JDK1-6和1-7中的实现\" class=\"headerlink\" title=\"1. JDK1.6和1.7中的实现\"></a>1. JDK1.6和1.7中的实现</h2><h3 id=\"1-1-设计思路\"><a href=\"#1-1-设计思路\" class=\"headerlink\" title=\"1.1 设计思路\"></a>1.1 设计思路</h3><p>在jdk1.6和1.7中采用了锁分段的技术实现，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争，相比于HashTable对整个map加锁的设计，分段锁大大的提高了高并发环境下的处理能力，正因为不是对整个map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的；</p>\n<p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p>\n<pre><code>static final class HashEntry&lt;K,V&gt; {\n    final int hash;\n    final K key;\n    volatile V value;\n    volatile HashEntry&lt;K,V&gt; next;\n</code></pre><h3 id=\"1-2-并发度（Concurrency-Level）\"><a href=\"#1-2-并发度（Concurrency-Level）\" class=\"headerlink\" title=\"1.2 并发度（Concurrency Level）\"></a>1.2 并发度（Concurrency Level）</h3><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p>\n<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）。</p>\n<h3 id=\"1-3-创建分段锁\"><a href=\"#1-3-创建分段锁\" class=\"headerlink\" title=\"1.3 创建分段锁\"></a>1.3 创建分段锁</h3><p>和JDK6不同，JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。</p>\n<p>ensureSegment可能在并发环境下被调用，但与想象中不同，ensureSegment并未使用锁来控制竞争，而是使用了Unsafe对象的getObjectVolatile()提供的原子读语义结合CAS来确保Segment创建的原子性。代码段如下：<br>    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                == null) { // recheck<br>                Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);<br>                while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                       == null) {<br>                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))<br>                        break;<br>                }<br>}</p>\n<h3 id=\"1-4-put-putIfAbsent-putAll\"><a href=\"#1-4-put-putIfAbsent-putAll\" class=\"headerlink\" title=\"1.4 put/putIfAbsent/putAll\"></a>1.4 put/putIfAbsent/putAll</h3><p>和JDK6一样，ConcurrentHashMap的put方法被代理到了对应的Segment（定位Segment的原理之前已经描述过）中。与JDK6不同的是，JDK7版本的ConcurrentHashMap在获得Segment锁的过程中，做了一定的优化 - 在真正申请锁之前，put方法会通过tryLock()方法尝试获得锁，在尝试获得锁的过程中会对对应hashcode的链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数后仍无法获得锁，则通过lock申请锁。</p>\n<p>需要注意的是，由于在并发环境下，其他线程的put，rehash或者remove操作可能会导致链表头结点的变化，因此在过程中需要进行检查，如果头结点发生变化则重新对表进行遍历。而如果其他线程引起了链表中的某个节点被删除，即使该变化因为是非原子写操作（删除节点后链接后续节点调用的是Unsafe.putOrderedObject()，该方法不提供原子写语义）可能导致当前线程无法观察到，但因为不影响遍历的正确性所以忽略不计。</p>\n<p>之所以在获取锁的过程中对整个链表进行遍历，主要目的是希望遍历的链表被CPU cache所缓存，为后续实际put过程中的链表遍历操作提升性能。</p>\n<p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值，否则新建一个HashEntry节点，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p>\n<p>put方法中，链接新节点的下一个节点（HashEntry.setNext()）以及将链表写入到数组中（setEntryAt()）都是通过Unsafe的putOrderedObject()方法来实现，这里并未使用具有原子写语义的putObjectVolatile()的原因是：JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后更新到主存，从而保证这些变更对其他线程是可见的。</p>\n<h3 id=\"1-5-rehash\"><a href=\"#1-5-rehash\" class=\"headerlink\" title=\"1.5 rehash\"></a>1.5 rehash</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：<br>    private void rehash(HashEntry&lt;K,V&gt; node) {<br>           HashEntry&lt;K,V&gt;[] oldTable = table;<br>           int oldCapacity = oldTable.length;<br>           int newCapacity = oldCapacity &lt;&lt; 1;<br>           threshold = (int)(newCapacity * loadFactor);<br>           HashEntry&lt;K,V&gt;[] newTable =<br>               (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];<br>           int sizeMask = newCapacity - 1;<br>           for (int i = 0; i &lt; oldCapacity ; i++) {<br>               HashEntry&lt;K,V&gt; e = oldTable[i];<br>               if (e != null) {<br>                   HashEntry&lt;K,V&gt; next = e.next;<br>                   int idx = e.hash &amp; sizeMask;<br>                   if (next == null)   //  Single node on list<br>                       newTable[idx] = e;<br>                   else { // Reuse consecutive sequence at same slot<br>                       HashEntry&lt;K,V&gt; lastRun = e;<br>                       int lastIdx = idx;<br>                       for (HashEntry&lt;K,V&gt; last = next;<br>                            last != null;<br>                            last = last.next) {<br>                           int k = last.hash &amp; sizeMask;<br>                           if (k != lastIdx) {<br>                               lastIdx = k;<br>                               lastRun = last;<br>                           }<br>                       }<br>                       newTable[lastIdx] = lastRun;<br>                       // Clone remaining nodes<br>                       for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {<br>                           V v = p.value;<br>                           int h = p.hash;<br>                           int k = h &amp; sizeMask;<br>                           HashEntry&lt;K,V&gt; n = newTable[k];<br>                           newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                       }<br>                   }<br>               }<br>           }<br>           int nodeIndex = node.hash &amp; sizeMask; // add the new node<br>           node.setNext(newTable[nodeIndex]);<br>           newTable[nodeIndex] = node;<br>           table = newTable;<br>       }</p>\n<h3 id=\"1-6-remove\"><a href=\"#1-6-remove\" class=\"headerlink\" title=\"1.6 remove\"></a>1.6 remove</h3><p>和put类似，remove在真正获得锁之前，也会对链表进行遍历以提高缓存命中率。</p>\n<h3 id=\"1-7-get与containsKey\"><a href=\"#1-7-get与containsKey\" class=\"headerlink\" title=\"1.7 get与containsKey\"></a>1.7 get与containsKey</h3><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p>\n<h3 id=\"1-8-size、containsValue\"><a href=\"#1-8-size、containsValue\" class=\"headerlink\" title=\"1.8 size、containsValue\"></a>1.8 size、containsValue</h3><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment（通过Unsafe的getObjectVolatile()以保证原子读语义），获得对应的值以及所有Segment的modcount之和。如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p>\n<p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。值得注意的是，加锁过程中要强制创建所有的Segment，否则容易出现其他线程创建Segment并进行put，remove等操作。代码如下：</p>\n<pre><code>for(int j =0; j &lt; segments.length; ++j)\n     ensureSegment(j).lock();// force creation\n</code></pre><p>一般来说，应该避免在多线程环境下使用size和containsValue方法。</p>\n<blockquote>\n<p>注1：modcount在put, replace, remove以及clear等方法中都会被修改。</p>\n</blockquote>\n<blockquote>\n<p>注2：对于containsValue方法来说，如果在循环过程中发现匹配value的HashEntry，则直接返回true。</p>\n</blockquote>\n<p>最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，需要特殊处理。在JDK6中，get方法的实现中就有一段对HashEntry.value == null的防御性判断。但Doug Lea也承认实际运行过程中，这种情况似乎不可能发生。</p>\n<h2 id=\"2-JDK8中的实现\"><a href=\"#2-JDK8中的实现\" class=\"headerlink\" title=\"2. JDK8中的实现\"></a>2. JDK8中的实现</h2>","comments":true,"categories":[{"name":"并发编程","slug":"并发编程","permalink":"itratel.github.io/categories/并发编程/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"itratel.github.io/tags/并发编程/"},{"name":"数据结构","slug":"数据结构","permalink":"itratel.github.io/tags/数据结构/"}]},{"title":"为什么String类是不可变的","date":"2018-07-30T13:23:41.000Z","path":"2018/07/30/为什么String类是不可变的/","content":"<p>String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。</p>\n<a id=\"more\"></a>\n<h3 id=\"String类不可变性的好处\"><a href=\"#String类不可变性的好处\" class=\"headerlink\" title=\"String类不可变性的好处\"></a>String类不可变性的好处</h3><ul>\n<li><p>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p>\n</li>\n<li><p>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p>\n</li>\n<li><p>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>\n</li>\n<li><p>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p>\n</li>\n<li><p>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串</p>\n</li>\n</ul>\n<blockquote>\n<p>如果觉得翻译不好的，可以查看原文<a href=\"https://www.journaldev.com/802/string-immutable-final-java\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"itratel.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"String","slug":"String","permalink":"itratel.github.io/tags/String/"}]},{"title":"Consulu服务注册和发现","date":"2018-07-05T14:53:22.000Z","path":"2018/07/05/Consul服务注册和发现/","content":"<h3 id=\"Introduction-to-Consul\"><a href=\"#Introduction-to-Consul\" class=\"headerlink\" title=\"Introduction to Consul\"></a>Introduction to Consul</h3><p>欢迎来到Consul导览!这本指南是我们从Consul开始的最好地方。我们将介绍Consul是什么，它可以解决什么问题，它如何与现有的软件进行比较，以及如何开始使用它。如果您熟悉Consul的基本知识，那么文档将提供可用特性的更详细参考.</p>\n<a id=\"more\"></a>\n<h3 id=\"What-is-Consul\"><a href=\"#What-is-Consul\" class=\"headerlink\" title=\"What is Consul?\"></a>What is Consul?</h3><p>Consul(<a href=\"https://www.consul.io/\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/</a>) 是一个服务网格解决方案，提供了一个功能齐全的控制平面与服务发现，配置，和分割功能。这些特性可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。Consul需要一个数据平面，并支持代理和本地集成模型。Consul船与一个简单的内置代理，使一切工作开箱，但也支持第三方代理集成，如特使</p>\n<p>其官方网站上列出了它的五点主要功能：</p>\n<ul>\n<li>服务发现<br>Consul的客户端可以注册服务，如api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以很容易地找到它们所依赖的服务</li>\n<li>健康检查<br>Consul客户端可以提供任意数量的健康检查，要么与给定的服务关联(“web服务器是否返回200 OK”)，要么与本地节点关联(“内存利用率是否低于90%”)。操作员可以使用这些信息来监视集群的健康状况，服务发现组件可以使用这些信息来将流量路由到不健康的主机,关于健康检查的更多信息，可以参考 <a href=\"https://www.consul.io/docs/agent/checks.html。\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/docs/agent/checks.html。</a></li>\n<li>KV 存储<br>应用程序可以使用Consul的分层密钥/值存储用于任何目的，包括动态配置、特性标记、协调、领导人选举等。简单的HTTP API使其易于使用。</li>\n<li>安全服务通信<br>Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。意图可以用来定义允许哪些服务进行通信。服务细分可以很容易地管理，其意图可以实时更改，而无需使用复杂的网络拓扑和静态防火墙规则。</li>\n<li>多数据中心支持<br>Consul支持多个数据中心开箱即用。这意味着Consul的用户不必担心构建额外的抽象层来扩展到多个区域。</li>\n</ul>\n<h3 id=\"Consul的基本机构\"><a href=\"#Consul的基本机构\" class=\"headerlink\" title=\"Consul的基本机构\"></a>Consul的基本机构</h3><p>Consul是一个分布式的，高度可用的系统。本节将介绍基本知识，有意省略一些不必要的细节，以便您能够快速了解Consul是如何工作的。有关更多细节，请参阅深入的体系结构概述。</p>\n<p>为Consul提供服务的每个节点都运行一个Consul代理。运行代理不需要发现其他服务或获取/设置键/值数据。代理负责对节点上的服务以及节点本身进行健康检查。</p>\n<p>代理与一个或多个Consul服务器通信。Consul服务器是存储和复制数据的地方。服务器自己选举一个领导者。虽然Consul可以与一台服务器一起工作，但建议使用3到5来避免导致数据丢失的故障场景。对于每个数据中心，建议使用一组Consul服务器。</p>\n<p>需要发现其他服务或节点的基础设施组件可以查询任何Consul服务器或任何Consul代理。代理自动将查询转发到服务器。</p>\n<p>每个数据中心运行一个Consul服务器集群。当跨数据中心服务发现或配置请求发出时，本地Consul服务器将请求转发到远程数据中心并返回结果。</p>\n<h3 id=\"Consul的安装和启动\"><a href=\"#Consul的安装和启动\" class=\"headerlink\" title=\"Consul的安装和启动\"></a>Consul的安装和启动</h3><p>要使用Consul，我们需要先安装它。Consul是用golang开发的(GitHub 地址为：<a href=\"https://github.com/hashicorp/consul\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/consul</a> ),其分发的安装包里包含的是针<br>对各个不同平台预先编译好的二进制文件，解压即可使用。安装包可以到<a href=\"https://www.consul.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/downloads.html</a> 下载获得。以 Linux 为例，我们可以<br>通过一下命令来完成安装：</p>\n<h5 id=\"1-下载-consul，这里用-linux-64bit-的-1-0-7-版本\"><a href=\"#1-下载-consul，这里用-linux-64bit-的-1-0-7-版本\" class=\"headerlink\" title=\"1.下载 consul，这里用 linux 64bit 的 1.0.7 版本\"></a>1.下载 consul，这里用 linux 64bit 的 1.0.7 版本</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -LO https://releases.hashicorp.com/consul/1.0.7/</span><br><span class=\"line\">consul_1.0.7_linux_amd64.zip</span><br><span class=\"line\">% Total % Received % Xferd Average Speed Time Time Time Current</span><br><span class=\"line\">Dload Upload Total Spent Left Speed</span><br><span class=\"line\">100 11.7M 100 11.7M 0 0 1477k 0 0:00:08 0:00:08 --:--:-- 2466k</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\"><a href=\"#2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\" class=\"headerlink\" title=\"2.解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）\"></a>2.解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unzip consul_1.0.7_linux_amd64.zip</span><br><span class=\"line\">Archive: consul_1.0.7_linux_amd64.zip</span><br><span class=\"line\">inflating: consul</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-将-consul-移动到-PATH-中，方便后续敲命令\"><a href=\"#3-将-consul-移动到-PATH-中，方便后续敲命令\" class=\"headerlink\" title=\"3.将 consul 移动到$PATH 中，方便后续敲命令\"></a>3.将 consul 移动到$PATH 中，方便后续敲命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mv consul /usr/<span class=\"built_in\">local</span>/bin 完成后，我们可以用 consul --version 命令来验证一下：</span><br><span class=\"line\">$ consul --version</span><br><span class=\"line\">Consul v1.0.7 Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when</span><br><span class=\"line\">speaking to compatible agents)</span><br></pre></td></tr></table></figure>\n<p>好了，consul 安装成功了。接下来我们启动 consul。Consul agent 是 Consul的核心进程，它可以工作在client或server模式下。关于Consul的架构以及如何搭建 Consul 集群超出了本文要讨论的范围，感兴趣的读者可以参考 <a href=\"https://www.consul.io/docs/internals/architecture.html。\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/docs/internals/architecture.html。</a> 这里，我们采用一种简单(不推荐在生产环境使用）的方式来启动一个Consul agent:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ consul agent -data-dir=/tmp/consul -dev -<span class=\"built_in\">bind</span>=127.0.0.1</span><br><span class=\"line\">==&gt; Starting Consul agent...</span><br><span class=\"line\">==&gt; Consul agent running!</span><br><span class=\"line\">Version: <span class=\"string\">'v1.0.7'</span></span><br><span class=\"line\">Node ID: <span class=\"string\">'17028164-ad99-b9f4-6769-b74fcfce6f96'</span></span><br><span class=\"line\">Node name: <span class=\"string\">'brian-pc'</span></span><br><span class=\"line\">Datacenter: <span class=\"string\">'dc1'</span> (Segment: <span class=\"string\">'&lt;all&gt;'</span>)</span><br><span class=\"line\">Server: <span class=\"literal\">true</span> (Bootstrap: <span class=\"literal\">false</span>)</span><br><span class=\"line\">Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, DNS: 8600)</span><br><span class=\"line\">Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)</span><br><span class=\"line\">Encrypt: Gossip: <span class=\"literal\">false</span>, TLS-Outgoing: <span class=\"literal\">false</span>, TLS-Incoming: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>从输出的日志，我们可以看到这个agent工作在 Server模式下(Server:true），并监听了8500端口。在浏览器中输入 <a href=\"http://127.0.0.1:8500\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8500</a> 我们可以看到<br>如下界面：</p>\n","comments":true,"categories":[{"name":"微服务","slug":"微服务","permalink":"itratel.github.io/categories/微服务/"}],"tags":[{"name":"spring","slug":"spring","permalink":"itratel.github.io/tags/spring/"},{"name":"consul","slug":"consul","permalink":"itratel.github.io/tags/consul/"},{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"微服务","slug":"微服务","permalink":"itratel.github.io/tags/微服务/"}]},{"title":"十大排序算法","date":"2018-06-29T12:39:14.000Z","path":"2018/06/29/十大排序算法/","content":"<p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。排序算法大体可分为两种：一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。这里我们来探讨一下常用的算法。</p>\n<a id=\"more\"></a>\n<h4 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1.冒泡排序\"></a>1.冒泡排序</h4><p><a href=\"https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/BubbleSort.java\" target=\"_blank\" rel=\"noopener\">1.冒泡排序</a></p>\n<blockquote>\n<p>算法思想：从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端</p>\n</blockquote>\n<p>算法步骤：<br>（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最后一个数。如果发生交换，则继续下面的步骤，如果未发生交换，则数组有序，排序结束，此时时间复杂度为O(n)；<br>（2）每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。重复步骤（1）。</p>\n<p>稳定性：稳定排序。</p>\n<p>时间复杂度： O(n)至O(n2)，平均时间复杂度为O(n2)。<br>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次，且没有移动，时间复杂度为O(n)。<br>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值：<br>比较次数:Cmax=∑i=1n−1(n−i)=n(n−1)/2=O(n2)<br>移动次数等于比较次数，因此最坏时间复杂度为O(n2)。</p>\n<p><a href=\"https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/QuickSort.java\" target=\"_blank\" rel=\"noopener\">2.快速排序</a><br>快速排序（Quicksort）是对冒泡排序的一种改进</p>\n<blockquote>\n<p>算法思想： 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n</blockquote>\n<p>(1)设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>(2)以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>(3)从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>(4)从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>(5)重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>\n<p>稳定性：不稳定排序。</p>\n<p>时间复杂度： O（nlog2n）至O(n2)，平均时间复杂度为O（nlgn）。<br>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为O（nlog2n）。<br>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：<br>Cmax=∑i=1n−1(n−i)=n(n−1)/2=O(n2)</p>\n","comments":true,"categories":[{"name":"算法","slug":"算法","permalink":"itratel.github.io/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"itratel.github.io/tags/排序/"},{"name":"算法","slug":"算法","permalink":"itratel.github.io/tags/算法/"}]},{"title":"Hibernate中get()和load()的区别","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Hibernate中get()和load()的区别/","content":"<p>最近面试中遇到了关于hibernate中get()和load()两个方法的区别,我在论坛看到了各种论述，我总结了他们的观点以及自己的理解来简单说明下，如果有哪里不对的地方欢迎指正。</p>\n<a id=\"more\"></a>\n<h2 id=\"返回结果\"><a href=\"#返回结果\" class=\"headerlink\" title=\"返回结果\"></a>返回结果</h2><p>首先要清楚一点的是get()和load()方法都是hibernate中session中获取实体对象两个方法,如果是get()方法加载实体对象，但是如果加载对象失败的话，那么结果会返回为null，而通过load()方式加载实体对象，加载不到的数据话便会抛出ObjectNotFoundException。</p>\n<hr>\n<h2 id=\"执行机制\"><a href=\"#执行机制\" class=\"headerlink\" title=\"执行机制\"></a>执行机制</h2><h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get( )方法\"></a>get( )方法</h3><p>对于get( )方法，hibernate会确认一下该id对应的数据是否存在，首先会在session一级缓存中查找，如果在session缓存中找到了该id对应的对象；</p>\n<ul>\n<li><p>如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象;</p>\n</li>\n<li><p>如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据;</p>\n</li>\n<li>如果该id对应的对象并且不是被延迟加载的代理对象，或者在session缓存中没有找到该对象，则查找二级缓存</li>\n</ul>\n<p>如果二级缓存中没有的话，就会直接发送sql语句去数据库查询数据返回实体对象，如果数据库中也没有就返回null。</p>\n<h3 id=\"load-方法\"><a href=\"#load-方法\" class=\"headerlink\" title=\"load()方法\"></a>load()方法</h3><p>对于load方法加载实体对象的时，会根据*.hbm.xml映射文件上类级别的lazy属性的配置(默认为true)选择加载方式；</p>\n<ul>\n<li><p>若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)，这个代理对象只保存了实体对象的id值，当我们使用该对象的其他属性值时就会查找二级缓存，二级缓存没有就发出sql语句去数据库查找数据，如果数据库仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。这也是我们时常所说的<strong>延迟加载 </strong></p>\n</li>\n<li><p>若为false，就跟get( )方法加载顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException;</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"使用get-和load-时的注意事项\"><a href=\"#使用get-和load-时的注意事项\" class=\"headerlink\" title=\"使用get( )和load( )时的注意事项\"></a>使用get( )和load( )时的注意事项</h2><p>当我们了解了load和get的加载机制以后，在以后使用过程后需要注意一些问题：</p>\n<ul>\n<li><p>如果使用get方式来加载对象，当我们试图得到一个id不存在的对象时，此时会报NullPointException,这是因为通过get( )方式加载实体对象时候，我们会去数据库中查询出该对象，但是这个id值不存在，所以此时实体对象是null，也就会报NullPointException。</p>\n</li>\n<li><p>如果使用load方式来加载对象，当我们试图得到一个id不存在的实体对象时，此时会报ObjectNotFoundException，为什么使用load的方式和get的方式来得到一个不存在的对象报的异常不同呢？？其原因还是因为load的延迟加载机制，使用load()时，此时的实体对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的其他属性时，这个属性其实是为空，所以就会报ObjectNotFoundException</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之对于get( )和load( )的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get( )方法，hibernate一定要获取到真实的数据，否则返回null。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"itratel.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"itratel.github.io/tags/hibernate/"}]},{"title":"IntelliJ IDEA的使用","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/IntelliJ-idea的快捷键的使用/","content":"<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p>\n<a id=\"more\"></a>\n<h2 id=\"快捷键的使用\"><a href=\"#快捷键的使用\" class=\"headerlink\" title=\"快捷键的使用\"></a>快捷键的使用</h2><blockquote>\n<p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p>\n</blockquote>\n<h3 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h3><ul>\n<li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li>\n<li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li>\n<li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li>\n<li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li>\n<li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li>\n<li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li>\n<li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li>\n<li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li>\n<li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li>\n</ul>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><ul>\n<li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li>\n<li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li>\n<li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li>\n<li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li>\n</ul>\n<h3 id=\"列操作\"><a href=\"#列操作\" class=\"headerlink\" title=\"列操作\"></a>列操作</h3><ul>\n<li>列选<br> Ctrl + Shift + Alt + J : 列选 </li>\n</ul>\n","comments":true,"categories":[{"name":"编程工具","slug":"编程工具","permalink":"itratel.github.io/categories/编程工具/"}],"tags":[{"name":"IntelliJ idea","slug":"IntelliJ-idea","permalink":"itratel.github.io/tags/IntelliJ-idea/"},{"name":"jetbrains","slug":"jetbrains","permalink":"itratel.github.io/tags/jetbrains/"}]},{"title":"Bootstrap-table分页删除尾页数据后刷新无数据问题","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/ubuntu16.04.3安装rabbitmq服务器/","content":"<blockquote>\n<p>当我们使用bootstrap-table做表格分页展示的时候，当我们删除最后一页数据的时候，刷新数据发现无数据展示, 针对这种问题，我们有三种解决方式；</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n","comments":true,"categories":[{"name":"前端","slug":"前端","permalink":"itratel.github.io/categories/前端/"}],"tags":[{"name":"bootstrap-table","slug":"bootstrap-table","permalink":"itratel.github.io/tags/bootstrap-table/"},{"name":"js","slug":"js","permalink":"itratel.github.io/tags/js/"}]},{"title":"ubuntu16.04.3安装RabbitMQ服务器","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/","content":"<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构，关于消息队列，市面上有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ这样一些消息队列，但是目前大家用得最多的就是Kafka，<strong>RabbitMQ</strong>，ActiveMQ，但是我们常用的<strong>SpringBoot</strong>不支持ActiveMQ（支持Kafka，RabbitMQ），所以先动手实现在linux上安装RabbitMQ服务器。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>为了顺利，建议大家以官方文档，根据这个链接<a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a>实现安装;</p>\n</blockquote>\n<h3 id=\"添加新的源\"><a href=\"#添加新的源\" class=\"headerlink\" title=\"添加新的源\"></a>添加新的源</h3><ul>\n<li>添加新的源 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'deb http://www.rabbitmq.com/debian/ testing main'</span> | sudo tee /etc/apt/sources.list.d/rabbitmq.list</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"下载公钥\"><a href=\"#下载公钥\" class=\"headerlink\" title=\"下载公钥\"></a>下载公钥</h3><ul>\n<li>下载公钥，防止后面的安装出现安全警告（可选，不执行此步骤也不会影响安装）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"更新和安装\"><a href=\"#更新和安装\" class=\"headerlink\" title=\"更新和安装\"></a>更新和安装</h3><ul>\n<li><p>更新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这时候我们可以通过ps -ef|grep rabbit命令来看哈情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef|grep rabbit</span><br></pre></td></tr></table></figure></p>\n<p>使用上述命令边可以查看到如下信息：</p>\n<pre><code>rabbitmq  1609     1  0 21:46 ?        00:00:02 /usr/lib/erlang/erts-7.3/bin/beam -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbi boot -sname rabbit@iZwz9ajwdnsg4s5368tvcpZ -boot start_sasl -kernel inet_default_connect_options [{nodelay,true}] -sasl errlog_type error -sasl sasl_error_logger false -rabbit error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ.log&quot;} -rabbit sasl_error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ-sasl.log&quot;} -rabbit enabled_plugins_file &quot;/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins&quot; -rabbit plugins_expand_dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ&quot; -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672\nrabbitmq  1703     1  0 21:46 ?        00:00:00 /usr/lib/erlang/erts-7.3/bin/epmd -daemon\nrabbitmq  1811  1609  0 21:46 ?        00:00:00 inet_gethost 4\nrabbitmq  1812  1811  0 21:46 ?        00:00:00 inet_gethost 4\nroot      2059   394  0 22:02 pts/1    00:00:00 grep --color=auto rabbit\n</code></pre><blockquote>\n<p>注意：最新版本为了安全，默认只允许本地可访问，也就是说我们远程无法访问。还需要进行配置才行。</p>\n</blockquote>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>我这里使用的是ubuntu的系统，登录远程服务器，cd /etc/rabbitmq/下，</p>\n<ul>\n<li>新建rabbitmq.config文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch rabbitmq.config</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果不知道如何写配置文件，还是参照官网<a href=\"http://www.rabbitmq.com/access-control.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/access-control.html</a>完成自己的配置文件<br>配置文件的内容为：</p>\n<pre><code>[{rabbit, [{loopback_users, []}]}].\n</code></pre><p>如果我们想有一个web端可视化操作界面，我们还需要配置插件,先进入到安全目录：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/lib/rabbitmq/bin/ </span><br><span class=\"line\">$ ./rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></p>\n<p>最后别忘记了重启你的rabbitmq<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ invoke-rc.d rabbitmq-server restart</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>重新你启动后：输入./rabbitmqctl status查看启动状态：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./rabbitmqctl status</span><br></pre></td></tr></table></figure></p>\n<p>看到如下信息表示rabbitmq启动成功：</p>\n<pre><code>Status of node rabbit@iZwz9ajwdnsg4s5368tvcpZ\n[{pid,1616},\n {running_applications,\n     [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.15&quot;},\n      {rabbit,&quot;RabbitMQ&quot;,&quot;3.6.15&quot;},\n      {cowboy,&quot;Small, fast, modular HTTP server.&quot;,&quot;1.0.4&quot;},\n      {ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.3.2&quot;},\n      {ssl,&quot;Erlang/OTP SSL application&quot;,&quot;7.3&quot;},\n      {public_key,&quot;Public key infrastructure&quot;,&quot;1.1.1&quot;},\n      {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.4&quot;},\n      {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.15&quot;},\n      {rabbit_common,\n          &quot;Modules shared by rabbitmq-server and rabbitmq-erlang-client&quot;,\n          &quot;3.6.15&quot;},\n      {compiler,&quot;ERTS  CXC 138 10&quot;,&quot;6.0.3&quot;},\n      {inets,&quot;INETS  CXC 138 49&quot;,&quot;6.2&quot;},\n      {cowlib,&quot;Support library for manipulating Web protocols.&quot;,&quot;1.0.2&quot;},\n      {crypto,&quot;CRYPTO&quot;,&quot;3.6.3&quot;},\n      {asn1,&quot;The Erlang ASN1 compiler version 4.0.2&quot;,&quot;4.0.2&quot;},\n      {recon,&quot;Diagnostic tools for production use&quot;,&quot;2.3.2&quot;},\n      {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.13.3&quot;},\n      {syntax_tools,&quot;Syntax tools&quot;,&quot;1.7&quot;},\n      {xmerl,&quot;XML parser&quot;,&quot;1.3.10&quot;},\n      {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.7&quot;},\n      {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;2.8&quot;},\n      {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;4.2&quot;}]},\n {os,{unix,linux}},\n {erlang_version,\n     &quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [kernel-poll:true]\\n&quot;},\n {memory,\n     [{connection_readers,0},\n      {connection_writers,0},\n      {connection_channels,0},\n      {connection_other,2592},\n      {queue_procs,2592},\n      {queue_slave_procs,0},\n      {plugins,719912},\n      {other_proc,21169952},\n      {metrics,51816},\n      {mgmt_db,145272},\n      {mnesia,58224},\n      {other_ets,2325224},\n      {binary,59168},\n      {msg_index,40704},\n      {code,27779661},\n      {atom,1000601},\n      {other_system,4364826},\n      {allocated_unused,16974432},\n      {reserved_unallocated,0},\n      {total,72642560}]},\n {alarms,[]},\n {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;},{http,15672,&quot;::&quot;}]},\n {vm_memory_calculation_strategy,rss},\n {vm_memory_high_watermark,0.4},\n {vm_memory_limit,838947635},\n {disk_free_limit,50000000},\n {disk_free,36661555200},\n {file_descriptors,\n     [{total_limit,924},{total_used,2},{sockets_limit,829},{sockets_used,0}]},\n {processes,[{limit,1048576},{used,321}]},\n {run_queue,0},\n {uptime,602},\n {kernel,{net_ticktime,60}}]\n</code></pre><h2 id=\"后台管理\"><a href=\"#后台管理\" class=\"headerlink\" title=\"后台管理\"></a>后台管理</h2><p>在浏览器段查看rabbit的后台管理界面：</p>\n<ul>\n<li><p>首先，在自己的系统防火墙的端口号，后台管理界面的访问端口是15672,因此需要在执行以下命令开放该端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ firewall-cmd --add-port=15672/tcp --zone=public --permanent</span><br><span class=\"line\"></span><br><span class=\"line\">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于我的服务器是阿里云的ubuntu，因此需要登陆阿里云，进入你的管理控制台安全组入口配置规则，开放端口，在浏览器输入以下地址，便可访问后台管理界面。</p>\n<pre><code>你的服务器公网地址:15672\n</code></pre><p>效果如下:<br><img src=\"http://120.78.190.213/images/tomcat.jpg\" alt=\"\"></p>\n</li>\n</ul>\n","comments":true,"categories":[{"name":"中间件","slug":"中间件","permalink":"itratel.github.io/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"itratel.github.io/tags/RabbitMQ/"},{"name":"linux","slug":"linux","permalink":"itratel.github.io/tags/linux/"},{"name":"消息队列","slug":"消息队列","permalink":"itratel.github.io/tags/消息队列/"}]},{"title":"Hello World","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><a id=\"more\"></a>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","comments":true,"categories":[{"name":"github","slug":"github","permalink":"itratel.github.io/categories/github/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"itratel.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"itratel.github.io/tags/博客/"}]},{"title":"Git右键没有Git Bash Here的解决办法","date":"2018-06-02T11:25:50.000Z","path":"2018/06/02/Git右键没有Git-Bash-Here的解决办法/","content":"<p>大家经常会遇到的一个问题，大家在安装git完成的时候，一般用鼠标右键就可以看到Git Bash Here和Git Gui这两个选项，但是有时候安装git后并没有两个选项，这里我们将要介绍如何配置Git Bash Here这个命令。</p>\n<a id=\"more\"></a>\n<h3 id=\"出现原因\"><a href=\"#出现原因\" class=\"headerlink\" title=\"出现原因\"></a>出现原因</h3><p>对于各位右键看不到这个命令，出现这个问题的原因，主要是我在安装git的时候，安装路径没有在C盘下，安装在C盘下系统就会自动帮你创建这个命令，再右键就能看到这两个命令，如果你的git安装在其他盘符下，那么就需要你自己完成手动配置。</p>\n<h4 id=\"1-打开注册表\"><a href=\"#1-打开注册表\" class=\"headerlink\" title=\"1.打开注册表\"></a>1.打开注册表</h4><p>（win按键+R打开运行小窗口）在“运行”中输入‘regedit’，打开注册表。</p>\n<h4 id=\"2-创建shell文件夹\"><a href=\"#2-创建shell文件夹\" class=\"headerlink\" title=\"2.创建shell文件夹\"></a>2.创建shell文件夹</h4><p>在注册表编辑器界面  HKEY_CLASSES_ROOT\\Directory\\Background\\shell中进行设置，如果Background目录下没有shell文件夹就新建shell文件夹。</p>\n<h4 id=\"3-新建项\"><a href=\"#3-新建项\" class=\"headerlink\" title=\"3.新建项\"></a>3.新建项</h4><p>在shell目录下 新建项 Git Bash Here，此时点击鼠标右键菜单会出现“Git Bush Here”选项，但是你继续点击她，还不会打开git命令块。</p>\n<h4 id=\"4-添加图标\"><a href=\"#4-添加图标\" class=\"headerlink\" title=\"4.添加图标\"></a>4.添加图标</h4><p>到此时你会发现右键没有图标，我们可以给右键 Git Bush Here 快捷方式添加一个 Icon，这样看起来就美观很多，在Git Bash Here 项下 新建字符串值 Icon 然后编辑Icon 值 ，E:\\Git\\mingw64\\share\\git\\git-for-windows.ico ，注意：需要根据安装的Git真实目录进行配置。</p>\n<h4 id=\"5-新建Command项\"><a href=\"#5-新建Command项\" class=\"headerlink\" title=\"5.新建Command项\"></a>5.新建Command项</h4><p>在 Git Bash Here  下新建Command项，随后修改Command项的默认值修改为 E:\\Git\\bin\\bash.exe –login -i，注意：需要根据安装的Git真实目录进行配置。 此时你可以放心的使用Git Bush Here快捷方式了。<br><img src=\"/Git右键没有Git-Bash-Here的解决办法/git-bash-here.png\" alt=\"如图所示\"></p>\n","comments":true,"categories":[{"name":"版本控制","slug":"版本控制","permalink":"itratel.github.io/categories/版本控制/"}],"tags":[{"name":"git","slug":"git","permalink":"itratel.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"itratel.github.io/tags/版本控制/"}]},{"title":"注解的原理和应用","date":"2018-05-03T11:25:50.000Z","path":"2018/05/03/注解的原理和应用/","content":"<p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p>\n<a id=\"more\"></a>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h3 id=\"注解的分类\"><a href=\"#注解的分类\" class=\"headerlink\" title=\"注解的分类\"></a>注解的分类</h3><p>一般的注解护照要分为三类：</p>\n<h4 id=\"Java自带的标准注解\"><a href=\"#Java自带的标准注解\" class=\"headerlink\" title=\"Java自带的标准注解\"></a>Java自带的标准注解</h4><p>Java自带的标准注解主要包括包括@Override、@Deprecated和@SuppressWarnings三类，用这些注解标明后编译器就会进行检查；</p>\n<ul>\n<li>@Override 用于标明重写某个方法；</li>\n<li>@Deprecated 用于标明某个类或方法过时、标明要忽略的警告；</li>\n<li>@SuppressWarnings 用于申明要忽略的警告；</li>\n</ul>\n<h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解是用于定义注解的注解，主要包括@Retention、@Target、@Inherited、@Documented四个；</p>\n<ul>\n<li>@Retention     用于标明注解被保留的阶段;</li>\n<li>@Target          用于标明注解使用的范围;</li>\n<li>@Inherited     用于标明注解可继承;</li>\n<li>@Documented   用于标明是否生成javadoc文档；</li>\n</ul>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>自定义注解，程序员可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p>\n<h3 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h3><p>它主要的作用有以下四方面：</p>\n<ul>\n<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>\n</ul>\n<h3 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h3><p>注解的使用大体分为三部分：定义注解，使用注解和解析注解，标准注解非常简单，大家可以自己实现，同时现在存在很多的java框架（Spring,SpringBoot,SpringCloud,Hibernate）中间的注解，大家使用的比较多，框架中的注解一般已经做好注解的定义和注解的解析，我们程序员只需要使用它就是了，这里主要说明自定义注解的使用。</p>\n<h4 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h4><p>注解的定义通过@interface定义，然后在注解内部可以定义方法，很类似接口中的方法，但是在注解中他是一个成员变量，定义成员变量要遵守一些规则：<br>1.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。<br>2.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=）。<br>3.注解类可以没有成员，没有成员的注解称为标识注解<br>现在我们定义一个在方法上注解，里面有两个String类型的成员变量</p>\n<pre><code>@Documented\n@Target(ElementType.METHOD)\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AuthorAPI {\n    String author() default &quot;whd&quot;;\n    String comments() default  &quot;no comments&quot;;\n    int age() default 23;\n}\n</code></pre><h4 id=\"注解的使用-1\"><a href=\"#注解的使用-1\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h4><pre><code>public class UseAnnotation {\n\n    @AuthorAPI\n    public void getInfo(String name){\n        System.out.println(name);\n    }\n\n    @AuthorAPI(author = &quot;mtt&quot;, comments = &quot;you are pretty good&quot;, age = 20)\n    public void getDetail(String name){\n        System.out.println(name);\n    }\n\n    public void getInfomation(String name){\n        System.out.println(name);\n    }\n\n}\n</code></pre><h4 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h4><pre><code>public class TestAnnotation {\n\n    public static void main(String[] args) {\n        getSomeAuthorInfo(UseAnnotation.class);\n    }\n\n    private static void getSomeAuthorInfo(Class&lt;?&gt; clazz)  {\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(AuthorAPI.class)){\n                AuthorAPI annotation = method.getDeclaredAnnotation(AuthorAPI.class);\n                System.out.println(annotation.author() +&quot; &quot;+ annotation.comments() +&quot; &quot;+ annotation.age());\n                try {\n                    method.invoke(new UseAnnotation(), &quot;hello, baby&quot;);\n                } catch (IllegalAccessException | InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre><p>输出结果：</p>\n<pre><code>mtt you are pretty good 20\nhello, baby\nwhd no comments 23\nhello, baby\n</code></pre><p>我们发现只有添加AuthorAPI注解的方法才能获取到注解成员变量的值，当然你也可以实现其他的逻辑。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"itratel.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"annotation","slug":"annotation","permalink":"itratel.github.io/tags/annotation/"}]},{"title":"利用nginx搭建图片服务器","date":"2017-10-15T15:17:58.000Z","path":"2017/10/15/利用nginx搭建图片服务器/","content":"<p>&emsp;&emsp;大家经常在做项目的时候，特别是javaweb服务，对于图片等静态文件的处理都是放在项目里面的，这种方式在小型系统中是没有问题的，但是随着业务地不断增加，图片数量地增加，应用服务器的性能就会大幅度减小, 为了缓解应用服务器的压力, 搭建一个专门用来存储图片等静态资源的服务器是必须的，接下来就会教大家如何搭建一个图片服务器。</p>\n<a id=\"more\"></a>\n<h2 id=\"图片服务器的现状\"><a href=\"#图片服务器的现状\" class=\"headerlink\" title=\"图片服务器的现状\"></a>图片服务器的现状</h2>","comments":true,"categories":[{"name":"nginx","slug":"nginx","permalink":"itratel.github.io/categories/nginx/"}],"tags":[{"name":"图片服务器","slug":"图片服务器","permalink":"itratel.github.io/tags/图片服务器/"},{"name":"nginx","slug":"nginx","permalink":"itratel.github.io/tags/nginx/"}]},{"title":"Java8新特性之Optional","date":"2017-09-15T01:12:23.000Z","path":"2017/09/15/Java8新特性之Optional/","content":"<p>&emsp;&emsp;在我们的开发中，NullPointerException可谓是所有java程序员随时随处可见的一种异常，为了避免空指针异常，我们常常需要进行非空检查，如果你厌倦了空指针异常，可以考虑使用java8的Optional,它能够让你的代码更具有可读性，并保护其不受空指针异常的影响。<br><a id=\"more\"></a></p>\n<blockquote>\n<p><a href=\"https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html\" target=\"_blank\" rel=\"noopener\">英语比较好的话可以看官方原文</a></p>\n</blockquote>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h3><p>一位智者曾经说过，除非你处理过空指针异常，否则你不是一个真正的Java程序员。顺便说一句，null引用是许多问题的根源，因为它通常用于表示没有值，其实早在在Google Guava 中就有Optional，在Swift语言中也有这样类似的语法，因此Java SE 8引入了一个名为Java.util.Optional的新类，用来减轻这些问题。</p>\n<h3 id=\"2-类的说明\"><a href=\"#2-类的说明\" class=\"headerlink\" title=\"2.类的说明\"></a>2.类的说明</h3><h4 id=\"2-1-类中的所有属性和方法\"><a href=\"#2-1-类中的所有属性和方法\" class=\"headerlink\" title=\"2.1 类中的所有属性和方法\"></a>2.1 类中的所有属性和方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Optional</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Common instance for &#123;<span class=\"doctag\">@code</span> empty()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Optional&lt;?&gt; EMPTY = <span class=\"keyword\">new</span> Optional&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If non-null, the value; if null, indicates no value is present</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> T value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty instance.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Optional</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an empty &#123;<span class=\"doctag\">@code</span> Optional&#125; instance.  No value is present for this</span></span><br><span class=\"line\"><span class=\"comment\">    \t * Optional.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an instance with the value present.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Optional</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = Objects.requireNonNull(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an &#123;<span class=\"doctag\">@code</span> Optional&#125; with the specified present non-null value.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Optional&lt;&gt;(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an &#123;<span class=\"doctag\">@code</span> Optional&#125; describing the specified value, if non-null,</span></span><br><span class=\"line\"><span class=\"comment\">     * otherwise returns an empty &#123;<span class=\"doctag\">@code</span> Optional&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">ofNullable</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value == <span class=\"keyword\">null</span> ? empty() : of(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If a value is present in this &#123;<span class=\"doctag\">@code</span> Optional&#125;, returns the value,</span></span><br><span class=\"line\"><span class=\"comment\">     * otherwise throws &#123;<span class=\"doctag\">@code</span> NoSuchElementException&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span> Optional#isPresent()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"No value present\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Return &#123;<span class=\"doctag\">@code</span> true&#125; if there is a value present, otherwise &#123;<span class=\"doctag\">@code</span> false&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPresent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If a value is present, invoke the specified consumer with the value,</span></span><br><span class=\"line\"><span class=\"comment\">     * otherwise do nothing.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ifPresent</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            consumer.accept(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If a value is pre``sent, and the value matches the given predicate,</span></span><br><span class=\"line\"><span class=\"comment\">     * return an &#123;<span class=\"doctag\">@code</span> Optional&#125; describing the value, otherwise return an</span></span><br><span class=\"line\"><span class=\"comment\">     * empty &#123;<span class=\"doctag\">@code</span> Optional&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Optional&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(predicate);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> predicate.test(value) ? <span class=\"keyword\">this</span> : empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If a value is present, apply the provided mapping function to it,</span></span><br><span class=\"line\"><span class=\"comment\">     * and if the result is non-null, return an &#123;<span class=\"doctag\">@code</span> Optional&#125; describing the</span></span><br><span class=\"line\"><span class=\"comment\">     * result.  Otherwise return an empty &#123;<span class=\"doctag\">@code</span> Optional&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@apiNote</span> This method supports post-processing on optional values, without</span></span><br><span class=\"line\"><span class=\"comment\">     * the need to explicitly check for a return status.  For example, the</span></span><br><span class=\"line\"><span class=\"comment\">     * following code traverses a stream of file names, selects one that has</span></span><br><span class=\"line\"><span class=\"comment\">     * not yet been processed, and then opens that file, returning an</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@code</span> Optional&lt;FileInputStream&gt;&#125;:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;&#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\">     *     Optional&lt;FileInputStream&gt; fis =</span></span><br><span class=\"line\"><span class=\"comment\">     *         names.stream().filter(name -&gt; !isProcessedYet(name))</span></span><br><span class=\"line\"><span class=\"comment\">     *                       .findFirst()</span></span><br><span class=\"line\"><span class=\"comment\">     *                       .map(name -&gt; new FileInputStream(name));</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;&lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * If a value is present, apply the provided &#123;<span class=\"doctag\">@code</span> Optional&#125;-bearing</span></span><br><span class=\"line\"><span class=\"comment\">     * mapping function to it, return that result, otherwise return an empty</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@code</span> Optional&#125;.  This method is similar to &#123;<span class=\"doctag\">@link</span> #map(Function)&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">     * but the provided mapper is one whose result is already an &#123;<span class=\"doctag\">@code</span> Optional&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">     * and if invoked, &#123;<span class=\"doctag\">@code</span> flatMap&#125; does not wrap it with an additional</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@code</span> Optional&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title\">flatMap</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Return the value if present, otherwise return &#123;<span class=\"doctag\">@code</span> other&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">orElse</span><span class=\"params\">(T other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span> ? value : other;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Return the value if present, otherwise invoke &#123;<span class=\"doctag\">@code</span> other&#125; and return</span></span><br><span class=\"line\"><span class=\"comment\">     * the result of that invocation.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">orElseGet</span><span class=\"params\">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span> ? value : other.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Return the contained value, if present, otherwise throw an exception</span></span><br><span class=\"line\"><span class=\"comment\">     * to be created by the provided supplier.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@apiNote</span> A method reference to the exception constructor with an empty</span></span><br><span class=\"line\"><span class=\"comment\">     * argument list can be used as the supplier. For example,</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@code</span> IllegalStateException::new&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;X extends Throwable&gt; <span class=\"function\">T <span class=\"title\">orElseThrow</span><span class=\"params\">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class=\"keyword\">throws</span> X </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exceptionSupplier.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Indicates whether some other object is \"equal to\" this Optional. The</span></span><br><span class=\"line\"><span class=\"comment\">     * other object is considered equal if:</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;li&gt;it is also an &#123;<span class=\"doctag\">@code</span> Optional&#125; and;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;li&gt;both instances have no value present or;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;li&gt;the present values are \"equal to\" each other via &#123;<span class=\"doctag\">@code</span> equals()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(obj <span class=\"keyword\">instanceof</span> Optional)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.equals(value, other.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the hash code value of the present value, if any, or 0 (zero) if</span></span><br><span class=\"line\"><span class=\"comment\">     * no value is present.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a non-empty string representation of this Optional suitable for</span></span><br><span class=\"line\"><span class=\"comment\">     * debugging. The exact presentation format is unspecified and may vary</span></span><br><span class=\"line\"><span class=\"comment\">     * between implementations and versions.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@implSpec</span> If a value is present the result must include its string</span></span><br><span class=\"line\"><span class=\"comment\">     * representation in the result. Empty and present Optionals must be</span></span><br><span class=\"line\"><span class=\"comment\">     * unambiguously differentiable.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span></span><br><span class=\"line\">            ? String.format(<span class=\"string\">\"Optional[%s]\"</span>, value)</span><br><span class=\"line\">            : <span class=\"string\">\"Optional.empty\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-属性和方法解释\"><a href=\"#2-2-属性和方法解释\" class=\"headerlink\" title=\"2.2 属性和方法解释\"></a>2.2 属性和方法解释</h4><p>建议大家在学习新的知识的时候，先打开源码看看每个方法的注释说明，介绍了每个方法的作用，刚开始英语不好没关系，看得多了慢慢就会适应了，所以英语对程序员来讲是一个很重要的技能喔，接下来我们看哈每个方法的作用。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public static <t> Optional<t> of(T value)</t></t></td>\n<td>把指定的值封装为Optional对象，如果指定的值为null，则抛出NullPointerException</td>\n</tr>\n<tr>\n<td>public static<t> Optional<t> empty()</t></t></td>\n<td>创建一个空的Optional对象</td>\n</tr>\n<tr>\n<td>public static <t> Optional<t> ofNullable(T value)</t></t></td>\n<td>把指定的值封装为Optional对象，如果指定的值为null，则创建一个空的Optional对象</td>\n</tr>\n<tr>\n<td>public T get()</td>\n<td>如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException</td>\n</tr>\n<tr>\n<td>public T orElse(T other)</td>\n<td>如果创建的Optional中有值存在，则返回此值，否则返回一个默认值</td>\n</tr>\n<tr>\n<td>public T orElseGet(Supplier&lt;? extends T&gt; other)</td>\n<td>如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值</td>\n</tr>\n<tr>\n<td>public <x extends=\"\" throwable=\"\"> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></td>\n<td>如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常</td>\n</tr>\n<tr>\n<td>public Optional<t> filter(Predicate&lt;? super T&gt; predicate)</t></td>\n<td>如果创建的Optional中的值满足filter中的条件，则返回包含该值的Optional对象，否则返回一个空的Optional对象</td>\n</tr>\n<tr>\n<td>public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></u></td>\n<td>如果创建的Optional中的值存在，对该值执行提供的Function函数调用</td>\n</tr>\n<tr>\n<td>public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; mapper)</u></u></u></td>\n<td>如果创建的Optional中的值存在，就对该值执行提供的Function函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象</td>\n</tr>\n<tr>\n<td>public boolean isPresent()</td>\n<td>如果创建的Optional中的值存在，返回true，否则返回false</td>\n</tr>\n<tr>\n<td>public void ifPresent(Consumer&lt;? super T&gt; consumer)</td>\n<td>如果创建的Optional中的值存在，则执行该方法的调用，否则什么也不做</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-基本使用\"><a href=\"#3-基本使用\" class=\"headerlink\" title=\"3.基本使用\"></a>3.基本使用</h3><h4 id=\"3-1-对象创建\"><a href=\"#3-1-对象创建\" class=\"headerlink\" title=\"3.1 对象创建\"></a>3.1 对象创建</h4><ul>\n<li><p>创建一个空对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个空的Optional&lt;User&gt;对象</span></span><br><span class=\"line\">Optional&lt;User&gt; optStr = Optional.empty();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建对象：不允许为空<br>Optional提供了方法of()用于创建非空对象，该方法要求传入的参数不能为空，否则抛NullPointException，示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当user为null的时候，将抛出NullPointException</span></span><br><span class=\"line\">User user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Optional&lt;User&gt; optionals =  Optional.of(user);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://120.78.190.213/images/learn-java8/optional-of.png\" alt=\"如图示例\"></p>\n<ul>\n<li>创建对象：允许为空<br>如果不能确定传入的参数是否存在null值的可能性，则可以用Optional的ofNullable()方法创建对象，如果入参为null，则创建一个空对象。示例如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果user是null，则创建一个空对象</span></span><br><span class=\"line\">User user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Optional&lt;User&gt; optStr = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-2-存在则返回\"><a href=\"#3-2-存在则返回\" class=\"headerlink\" title=\"3.2 存在则返回\"></a>3.2 存在则返回</h4><ul>\n<li>get() 如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException，示例如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class=\"line\">User user1 = optional2.get();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://120.78.190.213/images/learn-java8/optional-get.png\" alt=\"如图示例\"></p>\n<ul>\n<li>orElse(T other) 如果创建的Optional中有值存在，则返回此值，否则返回一个默认值（默认值就是入参参入的值，这里传入null），示例如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class=\"line\">User user1 = optional2.orElse(<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://120.78.190.213/images/learn-java8/optional-orElse.png\" alt=\"如图示例\"></p>\n<ul>\n<li>orElseGet(Supplier&lt;? extends T&gt; other) 如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值（这个生成的值可为空），示例如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user3 = optional2.orElseGet(() -&gt; <span class=\"keyword\">null</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"user3: \"</span> + user3);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://120.78.190.213/images/learn-java8/optional-orElseGet.png\" alt=\"如图示例\"></p>\n<ul>\n<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)  如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user4 = optional2.orElseThrow(() -&gt; <span class=\"keyword\">null</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"user4: \"</span> + user4);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-3-Streams\"><a href=\"#3-3-Streams\" class=\"headerlink\" title=\"3.3 Streams\"></a>3.3 Streams</h4>","comments":true,"categories":[{"name":"java","slug":"java","permalink":"itratel.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"Optional","slug":"Optional","permalink":"itratel.github.io/tags/Optional/"}]},{"title":"多线程之线程顺序执行","date":"2017-06-03T11:25:50.000Z","path":"2017/06/03/多线程之线程顺序执行/","content":"<p>&emsp;&emsp;我们知道在多线程中，线程在启动的时候不是马上去执行任务的，而是由cpu调度让哪一个线程执行，通常情况下多线程的执行顺序是随机的，如果我们想要让线程按照一定的顺序让线程执行，怎么做呢？<br><a id=\"more\"></a></p>\n<h3 id=\"1-初见\"><a href=\"#1-初见\" class=\"headerlink\" title=\"1.初见\"></a>1.初见</h3><p>首先我们先上一段代码,看看执行效果。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread1 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread1 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread2 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread2 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread3 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread3 开始执行\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    thread3.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如图所示：<br><img src=\"http://120.78.190.213/images/multithread/multithread-orderexecute.png\" alt=\"如图示\"><br>从代码运行结果看，线程执行的顺序是随机的，我们无法保证线程按照特定的顺序执行，线程启动之后处于就绪状态，等待CPU调度执行，也就是说如果不做处理话，我们是无法控制的。</p>\n<h3 id=\"2-相恋\"><a href=\"#2-相恋\" class=\"headerlink\" title=\"2.相恋\"></a>2.相恋</h3><h4 id=\"2-1-设置线程优先级\"><a href=\"#2-1-设置线程优先级\" class=\"headerlink\" title=\"2.1 设置线程优先级\"></a>2.1 设置线程优先级</h4><p>线程的执行除了CPU调度外，还有一个因素就是每个线程的优先级，线程的级别有1-10个等级，级别越高表示线程越有可能拿到CPU时间片，但是并不是优先级越高的线程就一定比优先级低的线程更早获得CPU时间片执行任务呢，按但是否定的，我们只能说优先级高的线程更有可能获取的执行权，如果说优先级高的进入了等待，那么优先级低的线程就会执行，如果几个线程都处于就组状态，那毫无疑问优先级高的线程就会先执行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread1 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread1 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread2 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread2 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread3 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread3 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tthread3.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">\tthread2.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">\tthread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">\tthread1.start();</span><br><span class=\"line\">\tthread2.start();</span><br><span class=\"line\">\tthread3.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://120.78.190.213/images/multithread/multithread-orderexecute-priority.png\" alt=\"如图示\"></p>\n<h4 id=\"2-2-Thread-join\"><a href=\"#2-2-Thread-join\" class=\"headerlink\" title=\"2.2 Thread.join()\"></a>2.2 Thread.join()</h4><p>我们Thread.join()方法就是让主线程等待，新线程执行完了后再继续执行主线程，让我们来看一下Thread.join()方法的源码吧<br>源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    join(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">long</span> millis)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> base = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (millis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"timeout value is negative\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (millis == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (isAlive()) &#123;</span><br><span class=\"line\">                wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (isAlive()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> delay = millis - now;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                wait(delay);</span><br><span class=\"line\">                now = System.currentTimeMillis() - base;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码很清晰的告诉我们，当我们调用join()方法后，后调用join(long millis)，在millis == 0的情况下，如果当前线程是存活的，就让当前线程等待，让新线程继续执行知道死亡，知道原理后就来实现下代码喔。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread1 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread1 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread2 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread2 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread3 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread3 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread1.join();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    thread2.join();</span><br><span class=\"line\">    thread3.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://120.78.190.213/images/multithread/multithread-orderexecute-join.png\" alt=\"\"></p>\n<h4 id=\"2-3-Executors-newSingleThreadExecutor\"><a href=\"#2-3-Executors-newSingleThreadExecutor\" class=\"headerlink\" title=\"2.3 Executors.newSingleThreadExecutor()\"></a>2.3 Executors.newSingleThreadExecutor()</h4><p>Executors.newSingleThreadExecutor()就是创建一个只有一个线程线程池，让我们看了一个源码吧<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到Executors.newSingleThreadExecutor()实际上是创建了一个单线程的线程池，并且维护了一个任务队列，我们知道队列的特点就是FIFO(先进先出)，而且线程池每次只能执行一个任务线程，其余的线程实际上放到new LinkedBlockingQueue<runnable>()这个队列里等待CPU调度，当第一个线程执行完了后，线程池就会从队列取下一个任务线程来执行，以此类推，从而保证了线程的执行顺序，来看看代码怎么实现的吧<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread1 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread1 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread2 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread2 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Thread thread3 = <span class=\"keyword\">new</span> Thread(()-&gt;System.out.println(<span class=\"string\">\"thread3 开始执行\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    service.execute(thread1);</span><br><span class=\"line\">    service.execute(thread2);</span><br><span class=\"line\">    service.execute(thread3);</span><br><span class=\"line\">    service.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></runnable></p>\n<p><img src=\"http://120.78.190.213/images/multithread/multithread-orderexecute-executors.png\" alt=\"\"></p>\n<h3 id=\"婚恋\"><a href=\"#婚恋\" class=\"headerlink\" title=\"婚恋\"></a>婚恋</h3><p>以上就是控制多线程执行顺序方法，有什么不对欢迎指正喔。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"itratel.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"itratel.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"itratel.github.io/tags/多线程/"}]}]