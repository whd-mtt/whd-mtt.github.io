[{"title":"并发编程之ConcurrentHashMap原理分析","date":"2018-08-01T13:03:20.000Z","path":"2018/08/01/并发编程之ConcurrentHashMap原理分析/","content":"<p>&emsp;&emsp;在并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable和Collections.synchronizedMap()，前者在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS和锁分段的技术来减少锁竞争对于性能的影响，接下来我将分别阐述ConcurrentHashMap在JDK6/7/8分别是如何实现的。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-JDK1-6和1-7中的实现\"><a href=\"#1-JDK1-6和1-7中的实现\" class=\"headerlink\" title=\"1. JDK1.6和1.7中的实现\"></a>1. JDK1.6和1.7中的实现</h2><h3 id=\"1-1-设计思路\"><a href=\"#1-1-设计思路\" class=\"headerlink\" title=\"1.1 设计思路\"></a>1.1 设计思路</h3><p>在jdk1.6和1.7中采用了锁分段的技术实现，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争，相比于HashTable对整个map加锁的设计，分段锁大大的提高了高并发环境下的处理能力，正因为不是对整个map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的；</p>\n<p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p>\n<pre><code>static final class HashEntry&lt;K,V&gt; {\n    final int hash;\n    final K key;\n    volatile V value;\n    volatile HashEntry&lt;K,V&gt; next;\n</code></pre><h3 id=\"1-2-并发度（Concurrency-Level）\"><a href=\"#1-2-并发度（Concurrency-Level）\" class=\"headerlink\" title=\"1.2 并发度（Concurrency Level）\"></a>1.2 并发度（Concurrency Level）</h3><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p>\n<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）。</p>\n<h3 id=\"1-3-创建分段锁\"><a href=\"#1-3-创建分段锁\" class=\"headerlink\" title=\"1.3 创建分段锁\"></a>1.3 创建分段锁</h3><p>和JDK6不同，JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。</p>\n<p>ensureSegment可能在并发环境下被调用，但与想象中不同，ensureSegment并未使用锁来控制竞争，而是使用了Unsafe对象的getObjectVolatile()提供的原子读语义结合CAS来确保Segment创建的原子性。代码段如下：<br>    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                == null) { // recheck<br>                Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);<br>                while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                       == null) {<br>                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))<br>                        break;<br>                }<br>}</p>\n<h3 id=\"1-4-put-putIfAbsent-putAll\"><a href=\"#1-4-put-putIfAbsent-putAll\" class=\"headerlink\" title=\"1.4 put/putIfAbsent/putAll\"></a>1.4 put/putIfAbsent/putAll</h3><p>和JDK6一样，ConcurrentHashMap的put方法被代理到了对应的Segment（定位Segment的原理之前已经描述过）中。与JDK6不同的是，JDK7版本的ConcurrentHashMap在获得Segment锁的过程中，做了一定的优化 - 在真正申请锁之前，put方法会通过tryLock()方法尝试获得锁，在尝试获得锁的过程中会对对应hashcode的链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数后仍无法获得锁，则通过lock申请锁。</p>\n<p>需要注意的是，由于在并发环境下，其他线程的put，rehash或者remove操作可能会导致链表头结点的变化，因此在过程中需要进行检查，如果头结点发生变化则重新对表进行遍历。而如果其他线程引起了链表中的某个节点被删除，即使该变化因为是非原子写操作（删除节点后链接后续节点调用的是Unsafe.putOrderedObject()，该方法不提供原子写语义）可能导致当前线程无法观察到，但因为不影响遍历的正确性所以忽略不计。</p>\n<p>之所以在获取锁的过程中对整个链表进行遍历，主要目的是希望遍历的链表被CPU cache所缓存，为后续实际put过程中的链表遍历操作提升性能。</p>\n<p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值，否则新建一个HashEntry节点，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p>\n<p>put方法中，链接新节点的下一个节点（HashEntry.setNext()）以及将链表写入到数组中（setEntryAt()）都是通过Unsafe的putOrderedObject()方法来实现，这里并未使用具有原子写语义的putObjectVolatile()的原因是：JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后更新到主存，从而保证这些变更对其他线程是可见的。</p>\n<h3 id=\"1-5-rehash\"><a href=\"#1-5-rehash\" class=\"headerlink\" title=\"1.5 rehash\"></a>1.5 rehash</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：<br>    private void rehash(HashEntry&lt;K,V&gt; node) {<br>           HashEntry&lt;K,V&gt;[] oldTable = table;<br>           int oldCapacity = oldTable.length;<br>           int newCapacity = oldCapacity &lt;&lt; 1;<br>           threshold = (int)(newCapacity * loadFactor);<br>           HashEntry&lt;K,V&gt;[] newTable =<br>               (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];<br>           int sizeMask = newCapacity - 1;<br>           for (int i = 0; i &lt; oldCapacity ; i++) {<br>               HashEntry&lt;K,V&gt; e = oldTable[i];<br>               if (e != null) {<br>                   HashEntry&lt;K,V&gt; next = e.next;<br>                   int idx = e.hash &amp; sizeMask;<br>                   if (next == null)   //  Single node on list<br>                       newTable[idx] = e;<br>                   else { // Reuse consecutive sequence at same slot<br>                       HashEntry&lt;K,V&gt; lastRun = e;<br>                       int lastIdx = idx;<br>                       for (HashEntry&lt;K,V&gt; last = next;<br>                            last != null;<br>                            last = last.next) {<br>                           int k = last.hash &amp; sizeMask;<br>                           if (k != lastIdx) {<br>                               lastIdx = k;<br>                               lastRun = last;<br>                           }<br>                       }<br>                       newTable[lastIdx] = lastRun;<br>                       // Clone remaining nodes<br>                       for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {<br>                           V v = p.value;<br>                           int h = p.hash;<br>                           int k = h &amp; sizeMask;<br>                           HashEntry&lt;K,V&gt; n = newTable[k];<br>                           newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                       }<br>                   }<br>               }<br>           }<br>           int nodeIndex = node.hash &amp; sizeMask; // add the new node<br>           node.setNext(newTable[nodeIndex]);<br>           newTable[nodeIndex] = node;<br>           table = newTable;<br>       }</p>\n<h3 id=\"1-6-remove\"><a href=\"#1-6-remove\" class=\"headerlink\" title=\"1.6 remove\"></a>1.6 remove</h3><p>和put类似，remove在真正获得锁之前，也会对链表进行遍历以提高缓存命中率。</p>\n<h3 id=\"1-7-get与containsKey\"><a href=\"#1-7-get与containsKey\" class=\"headerlink\" title=\"1.7 get与containsKey\"></a>1.7 get与containsKey</h3><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p>\n<h3 id=\"1-8-size、containsValue\"><a href=\"#1-8-size、containsValue\" class=\"headerlink\" title=\"1.8 size、containsValue\"></a>1.8 size、containsValue</h3><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment（通过Unsafe的getObjectVolatile()以保证原子读语义），获得对应的值以及所有Segment的modcount之和。如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p>\n<p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。值得注意的是，加锁过程中要强制创建所有的Segment，否则容易出现其他线程创建Segment并进行put，remove等操作。代码如下：</p>\n<pre><code>for(int j =0; j &lt; segments.length; ++j)\n     ensureSegment(j).lock();// force creation\n</code></pre><p>一般来说，应该避免在多线程环境下使用size和containsValue方法。</p>\n<blockquote>\n<p>注1：modcount在put, replace, remove以及clear等方法中都会被修改。</p>\n</blockquote>\n<blockquote>\n<p>注2：对于containsValue方法来说，如果在循环过程中发现匹配value的HashEntry，则直接返回true。</p>\n</blockquote>\n<p>最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，需要特殊处理。在JDK6中，get方法的实现中就有一段对HashEntry.value == null的防御性判断。但Doug Lea也承认实际运行过程中，这种情况似乎不可能发生。</p>\n<h2 id=\"2-JDK8中的实现\"><a href=\"#2-JDK8中的实现\" class=\"headerlink\" title=\"2. JDK8中的实现\"></a>2. JDK8中的实现</h2>","comments":true,"categories":[{"name":"并发编程","slug":"并发编程","permalink":"whd-mtt.github.io/categories/并发编程/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"whd-mtt.github.io/tags/并发编程/"},{"name":"数据结构","slug":"数据结构","permalink":"whd-mtt.github.io/tags/数据结构/"}]},{"title":"为什么String类是不可变的","date":"2018-07-30T13:23:41.000Z","path":"2018/07/30/为什么String类是不可变的/","content":"<p>String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。</p>\n<a id=\"more\"></a>\n<h3 id=\"String类不可变性的好处\"><a href=\"#String类不可变性的好处\" class=\"headerlink\" title=\"String类不可变性的好处\"></a>String类不可变性的好处</h3><ul>\n<li><p>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p>\n</li>\n<li><p>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p>\n</li>\n<li><p>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>\n</li>\n<li><p>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p>\n</li>\n<li><p>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串</p>\n</li>\n</ul>\n<blockquote>\n<p>如果觉得翻译不好的，可以查看原文<a href=\"https://www.journaldev.com/802/string-immutable-final-java\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"String","slug":"String","permalink":"whd-mtt.github.io/tags/String/"}]},{"title":"Consulu服务注册和发现","date":"2018-07-05T14:53:22.000Z","path":"2018/07/05/Consulu服务注册和发现/","content":"<p>Consul（<a href=\"https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的</a> 4 点主要功能：<br><a id=\"more\"></a><br>服务发现<br>Consul 提供服务的注册与发现。服务的发现可以通过 DNS 或 HTTP。<br>● 健康检查<br>Consul 可以检查其客户端的健康状况 - 这通过客户端提供服务完成。除此之外，Consul 还可以检查整个机器节点的健康情况。关于健康检查的更多信息，<br>可以参考 <a href=\"https://www.consul.io/docs/agent/checks.html。\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/docs/agent/checks.html。</a><br>● KV 存储<br>Consul 提供了层级式（hierarchy）的键值对存储，应用程序可以用来完成几乎<br>任意的配置。<br>● 多数据中心支持<br>Consul 对多数据中心的支持是内建的，用户无需额外工作即可获得。</p>\n<h3 id=\"安装和启动-Consul\"><a href=\"#安装和启动-Consul\" class=\"headerlink\" title=\"安装和启动 Consul\"></a>安装和启动 Consul</h3><p>要使用 Consul，我们需要先安装它。Consul 是用 golang 开发的（GitHub 地址为：<a href=\"https://github.com/hashicorp/consul），其分发的安装包里包含的是针\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/consul），其分发的安装包里包含的是针</a><br>对各个不同平台预先编译好的二进制文件，解压即可使用。安装包可以到<a href=\"https://www.consul.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/downloads.html</a> 下载获得。以 Linux 为例，我们可以<br>通过一下命令来完成安装：</p>\n<h1 id=\"下载-consul，这里用-linux-64bit-的-1-0-7-版本\"><a href=\"#下载-consul，这里用-linux-64bit-的-1-0-7-版本\" class=\"headerlink\" title=\"下载 consul，这里用 linux 64bit 的 1.0.7 版本\"></a>下载 consul，这里用 linux 64bit 的 1.0.7 版本</h1><p>$ curl -LO <a href=\"https://releases.hashicorp.com/consul/1.0.7/\" target=\"_blank\" rel=\"noopener\">https://releases.hashicorp.com/consul/1.0.7/</a><br>consul_1.0.7_linux_amd64.zip<br>% Total % Received % Xferd Average Speed Time Time Time Current<br>Dload Upload Total Spent Left Speed<br>100 11.7M 100 11.7M 0 0 1477k 0 0:00:08 0:00:08 –:–:– 2466k</p>\n<h1 id=\"解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\"><a href=\"#解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\" class=\"headerlink\" title=\"解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）\"></a>解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）</h1><p>$ unzip consul_1.0.7_linux_amd64.zip<br>Archive: consul_1.0.7_linux_amd64.zip<br>inflating: consul</p>\n<h1 id=\"将-consul-移动到-PATH-中，方便后续敲命令\"><a href=\"#将-consul-移动到-PATH-中，方便后续敲命令\" class=\"headerlink\" title=\"将 consul 移动到$PATH 中，方便后续敲命令\"></a>将 consul 移动到$PATH 中，方便后续敲命令</h1><p>$ mv consul /usr/local/bin 完成后，我们可以用 consul –version 命令来验证一下：<br>$ consul –version<br>Consul v1.0.7 Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when<br>speaking to compatible agents)</p>\n","comments":true,"categories":[{"name":"微服务","slug":"微服务","permalink":"whd-mtt.github.io/categories/微服务/"}],"tags":[{"name":"spring","slug":"spring","permalink":"whd-mtt.github.io/tags/spring/"},{"name":"consul","slug":"consul","permalink":"whd-mtt.github.io/tags/consul/"},{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"微服务","slug":"微服务","permalink":"whd-mtt.github.io/tags/微服务/"}]},{"title":"ubuntu16.04.3安装RabbitMQ服务器","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/","content":"<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构，关于消息队列，市面上有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ这样一些消息队列，但是目前大家用得最多的就是Kafka，<strong>RabbitMQ</strong>，ActiveMQ，但是我们常用的<strong>SpringBoot</strong>不支持ActiveMQ（支持Kafka，RabbitMQ），所以先动手实现在linux上安装RabbitMQ服务器。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>为了顺利，建议大家以官方文档，根据这个链接<a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a>实现安装;</p>\n</blockquote>\n<h3 id=\"添加新的源\"><a href=\"#添加新的源\" class=\"headerlink\" title=\"添加新的源\"></a>添加新的源</h3><ul>\n<li>添加新的源 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'deb http://www.rabbitmq.com/debian/ testing main'</span> | sudo tee /etc/apt/sources.list.d/rabbitmq.list</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"下载公钥\"><a href=\"#下载公钥\" class=\"headerlink\" title=\"下载公钥\"></a>下载公钥</h3><ul>\n<li>下载公钥，防止后面的安装出现安全警告（可选，不执行此步骤也不会影响安装）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"更新和安装\"><a href=\"#更新和安装\" class=\"headerlink\" title=\"更新和安装\"></a>更新和安装</h3><ul>\n<li><p>更新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这时候我们可以通过ps -ef|grep rabbit命令来看哈情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef|grep rabbit</span><br></pre></td></tr></table></figure></p>\n<p>使用上述命令边可以查看到如下信息：</p>\n<pre><code>rabbitmq  1609     1  0 21:46 ?        00:00:02 /usr/lib/erlang/erts-7.3/bin/beam -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbi boot -sname rabbit@iZwz9ajwdnsg4s5368tvcpZ -boot start_sasl -kernel inet_default_connect_options [{nodelay,true}] -sasl errlog_type error -sasl sasl_error_logger false -rabbit error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ.log&quot;} -rabbit sasl_error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ-sasl.log&quot;} -rabbit enabled_plugins_file &quot;/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins&quot; -rabbit plugins_expand_dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ&quot; -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672\nrabbitmq  1703     1  0 21:46 ?        00:00:00 /usr/lib/erlang/erts-7.3/bin/epmd -daemon\nrabbitmq  1811  1609  0 21:46 ?        00:00:00 inet_gethost 4\nrabbitmq  1812  1811  0 21:46 ?        00:00:00 inet_gethost 4\nroot      2059   394  0 22:02 pts/1    00:00:00 grep --color=auto rabbit\n</code></pre><blockquote>\n<p>注意：最新版本为了安全，默认只允许本地可访问，也就是说我们远程无法访问。还需要进行配置才行。</p>\n</blockquote>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>我这里使用的是ubuntu的系统，登录远程服务器，cd /etc/rabbitmq/下，</p>\n<ul>\n<li>新建rabbitmq.config文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch rabbitmq.config</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果不知道如何写配置文件，还是参照官网<a href=\"http://www.rabbitmq.com/access-control.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/access-control.html</a>完成自己的配置文件<br>配置文件的内容为：</p>\n<pre><code>[{rabbit, [{loopback_users, []}]}].\n</code></pre><p>如果我们想有一个web端可视化操作界面，我们还需要配置插件,先进入到安全目录：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/lib/rabbitmq/bin/ </span><br><span class=\"line\">$ ./rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></p>\n<p>最后别忘记了重启你的rabbitmq<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ invoke-rc.d rabbitmq-server restart</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>重新你启动后：输入./rabbitmqctl status查看启动状态：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./rabbitmqctl status</span><br></pre></td></tr></table></figure></p>\n<p>看到如下信息表示rabbitmq启动成功：</p>\n<pre><code>Status of node rabbit@iZwz9ajwdnsg4s5368tvcpZ\n[{pid,1616},\n {running_applications,\n     [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.15&quot;},\n      {rabbit,&quot;RabbitMQ&quot;,&quot;3.6.15&quot;},\n      {cowboy,&quot;Small, fast, modular HTTP server.&quot;,&quot;1.0.4&quot;},\n      {ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.3.2&quot;},\n      {ssl,&quot;Erlang/OTP SSL application&quot;,&quot;7.3&quot;},\n      {public_key,&quot;Public key infrastructure&quot;,&quot;1.1.1&quot;},\n      {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.4&quot;},\n      {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.15&quot;},\n      {rabbit_common,\n          &quot;Modules shared by rabbitmq-server and rabbitmq-erlang-client&quot;,\n          &quot;3.6.15&quot;},\n      {compiler,&quot;ERTS  CXC 138 10&quot;,&quot;6.0.3&quot;},\n      {inets,&quot;INETS  CXC 138 49&quot;,&quot;6.2&quot;},\n      {cowlib,&quot;Support library for manipulating Web protocols.&quot;,&quot;1.0.2&quot;},\n      {crypto,&quot;CRYPTO&quot;,&quot;3.6.3&quot;},\n      {asn1,&quot;The Erlang ASN1 compiler version 4.0.2&quot;,&quot;4.0.2&quot;},\n      {recon,&quot;Diagnostic tools for production use&quot;,&quot;2.3.2&quot;},\n      {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.13.3&quot;},\n      {syntax_tools,&quot;Syntax tools&quot;,&quot;1.7&quot;},\n      {xmerl,&quot;XML parser&quot;,&quot;1.3.10&quot;},\n      {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.7&quot;},\n      {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;2.8&quot;},\n      {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;4.2&quot;}]},\n {os,{unix,linux}},\n {erlang_version,\n     &quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [kernel-poll:true]\\n&quot;},\n {memory,\n     [{connection_readers,0},\n      {connection_writers,0},\n      {connection_channels,0},\n      {connection_other,2592},\n      {queue_procs,2592},\n      {queue_slave_procs,0},\n      {plugins,719912},\n      {other_proc,21169952},\n      {metrics,51816},\n      {mgmt_db,145272},\n      {mnesia,58224},\n      {other_ets,2325224},\n      {binary,59168},\n      {msg_index,40704},\n      {code,27779661},\n      {atom,1000601},\n      {other_system,4364826},\n      {allocated_unused,16974432},\n      {reserved_unallocated,0},\n      {total,72642560}]},\n {alarms,[]},\n {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;},{http,15672,&quot;::&quot;}]},\n {vm_memory_calculation_strategy,rss},\n {vm_memory_high_watermark,0.4},\n {vm_memory_limit,838947635},\n {disk_free_limit,50000000},\n {disk_free,36661555200},\n {file_descriptors,\n     [{total_limit,924},{total_used,2},{sockets_limit,829},{sockets_used,0}]},\n {processes,[{limit,1048576},{used,321}]},\n {run_queue,0},\n {uptime,602},\n {kernel,{net_ticktime,60}}]\n</code></pre><h2 id=\"后台管理\"><a href=\"#后台管理\" class=\"headerlink\" title=\"后台管理\"></a>后台管理</h2><p>在浏览器段查看rabbit的后台管理界面：</p>\n<ul>\n<li><p>首先，在自己的系统防火墙的端口号，后台管理界面的访问端口是15672,因此需要在执行以下命令开放该端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ firewall-cmd --add-port=15672/tcp --zone=public --permanent</span><br><span class=\"line\"></span><br><span class=\"line\">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于我的服务器是阿里云的ubuntu，因此需要登陆阿里云，进入你的管理控制台安全组入口配置规则，开放端口，在浏览器输入以下地址，便可访问后台管理界面。</p>\n<pre><code>你的服务器公网地址:15672\n</code></pre><p>效果如下:<br><img src=\"/img/rabbitmq.png\" alt=\"\"></p>\n</li>\n</ul>\n","comments":true,"categories":[{"name":"中间件","slug":"中间件","permalink":"whd-mtt.github.io/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"whd-mtt.github.io/tags/RabbitMQ/"},{"name":"linux","slug":"linux","permalink":"whd-mtt.github.io/tags/linux/"},{"name":"消息队列","slug":"消息队列","permalink":"whd-mtt.github.io/tags/消息队列/"}]},{"title":"IntelliJ IDEA的使用","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/IntelliJ-idea的快捷键的使用/","content":"<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p>\n<a id=\"more\"></a>\n<h2 id=\"快捷键的使用\"><a href=\"#快捷键的使用\" class=\"headerlink\" title=\"快捷键的使用\"></a>快捷键的使用</h2><blockquote>\n<p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p>\n</blockquote>\n<h3 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h3><ul>\n<li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li>\n<li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li>\n<li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li>\n<li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li>\n<li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li>\n<li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li>\n<li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li>\n<li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li>\n<li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li>\n</ul>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><ul>\n<li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li>\n<li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li>\n<li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li>\n<li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li>\n</ul>\n<h3 id=\"列操作\"><a href=\"#列操作\" class=\"headerlink\" title=\"列操作\"></a>列操作</h3><ul>\n<li>列选<br> Ctrl + Shift + Alt + J : 列选 </li>\n</ul>\n","comments":true,"categories":[{"name":"编程工具","slug":"编程工具","permalink":"whd-mtt.github.io/categories/编程工具/"}],"tags":[{"name":"IntelliJ idea","slug":"IntelliJ-idea","permalink":"whd-mtt.github.io/tags/IntelliJ-idea/"},{"name":"jetbrains","slug":"jetbrains","permalink":"whd-mtt.github.io/tags/jetbrains/"}]},{"title":"Bootstrap-table分页删除尾页数据后刷新无数据问题","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/ubuntu16.04.3安装rabbitmq服务器/","content":"<blockquote>\n<p>当我们使用bootstrap-table做表格分页展示的时候，当我们删除最后一页数据的时候，刷新数据发现无数据展示, 针对这种问题，我们有三种解决方式；</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n","comments":true,"categories":[{"name":"前端","slug":"前端","permalink":"whd-mtt.github.io/categories/前端/"}],"tags":[{"name":"bootstrap-table","slug":"bootstrap-table","permalink":"whd-mtt.github.io/tags/bootstrap-table/"},{"name":"js","slug":"js","permalink":"whd-mtt.github.io/tags/js/"}]},{"title":"Hello World","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><a id=\"more\"></a>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","comments":true,"categories":[{"name":"github","slug":"github","permalink":"whd-mtt.github.io/categories/github/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"whd-mtt.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"whd-mtt.github.io/tags/博客/"}]},{"title":"Hibernate中get()和load()的区别","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Hibernate中get()和load()的区别/","content":"<p>最近面试中遇到了关于hibernate中get()和load()两个方法的区别,我在论坛看到了各种论述，我总结了他们的观点以及自己的理解来简单说明下，如果有哪里不对的地方欢迎指正。</p>\n<a id=\"more\"></a>\n<h2 id=\"返回结果\"><a href=\"#返回结果\" class=\"headerlink\" title=\"返回结果\"></a>返回结果</h2><p>首先要清楚一点的是get()和load()方法都是hibernate中session中获取实体对象两个方法,如果是get()方法加载实体对象，但是如果加载对象失败的话，那么结果会返回为null，而通过load()方式加载实体对象，加载不到的数据话便会抛出ObjectNotFoundException。</p>\n<hr>\n<h2 id=\"执行机制\"><a href=\"#执行机制\" class=\"headerlink\" title=\"执行机制\"></a>执行机制</h2><h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get( )方法\"></a>get( )方法</h3><p>对于get( )方法，hibernate会确认一下该id对应的数据是否存在，首先会在session一级缓存中查找，如果在session缓存中找到了该id对应的对象；</p>\n<ul>\n<li><p>如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象;</p>\n</li>\n<li><p>如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据;</p>\n</li>\n<li>如果该id对应的对象并且不是被延迟加载的代理对象，或者在session缓存中没有找到该对象，则查找二级缓存</li>\n</ul>\n<p>如果二级缓存中没有的话，就会直接发送sql语句去数据库查询数据返回实体对象，如果数据库中也没有就返回null。</p>\n<h3 id=\"load-方法\"><a href=\"#load-方法\" class=\"headerlink\" title=\"load()方法\"></a>load()方法</h3><p>对于load方法加载实体对象的时，会根据*.hbm.xml映射文件上类级别的lazy属性的配置(默认为true)选择加载方式；</p>\n<ul>\n<li><p>若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)，这个代理对象只保存了实体对象的id值，当我们使用该对象的其他属性值时就会查找二级缓存，二级缓存没有就发出sql语句去数据库查找数据，如果数据库仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。这也是我们时常所说的<strong>延迟加载 </strong></p>\n</li>\n<li><p>若为false，就跟get( )方法加载顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException;</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"使用get-和load-时的注意事项\"><a href=\"#使用get-和load-时的注意事项\" class=\"headerlink\" title=\"使用get( )和load( )时的注意事项\"></a>使用get( )和load( )时的注意事项</h2><p>当我们了解了load和get的加载机制以后，在以后使用过程后需要注意一些问题：</p>\n<ul>\n<li><p>如果使用get方式来加载对象，当我们试图得到一个id不存在的对象时，此时会报NullPointException,这是因为通过get( )方式加载实体对象时候，我们会去数据库中查询出该对象，但是这个id值不存在，所以此时实体对象是null，也就会报NullPointException。</p>\n</li>\n<li><p>如果使用load方式来加载对象，当我们试图得到一个id不存在的实体对象时，此时会报ObjectNotFoundException，为什么使用load的方式和get的方式来得到一个不存在的对象报的异常不同呢？？其原因还是因为load的延迟加载机制，使用load()时，此时的实体对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的其他属性时，这个属性其实是为空，所以就会报ObjectNotFoundException</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之对于get( )和load( )的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get( )方法，hibernate一定要获取到真实的数据，否则返回null。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"whd-mtt.github.io/tags/hibernate/"}]},{"title":"Git右键没有Git Bash Here的解决办法","date":"2018-06-02T11:25:50.000Z","path":"2018/06/02/Git右键没有Git-Bash-Here的解决办法/","content":"<p>大家经常会遇到的一个问题，大家在安装git完成的时候，一般用鼠标右键就可以看到Git Bash Here和Git Gui这两个选项，但是有时候安装git后并没有两个选项，这里我们将要介绍如何配置Git Bash Here这个命令。</p>\n<a id=\"more\"></a>\n<h3 id=\"出现原因\"><a href=\"#出现原因\" class=\"headerlink\" title=\"出现原因\"></a>出现原因</h3><p>对于各位右键看不到这个命令，出现这个问题的原因，主要是我在安装git的时候，安装路径没有在C盘下，安装在C盘下系统就会自动帮你创建这个命令，再右键就能看到这两个命令，如果你的git安装在其他盘符下，那么就需要你自己完成手动配置。</p>\n<h4 id=\"1-打开注册表\"><a href=\"#1-打开注册表\" class=\"headerlink\" title=\"1.打开注册表\"></a>1.打开注册表</h4><p>（win按键+R打开运行小窗口）在“运行”中输入‘regedit’，打开注册表。</p>\n<h4 id=\"2-创建shell文件夹\"><a href=\"#2-创建shell文件夹\" class=\"headerlink\" title=\"2.创建shell文件夹\"></a>2.创建shell文件夹</h4><p>在注册表编辑器界面  HKEY_CLASSES_ROOT\\Directory\\Background\\shell中进行设置，如果Background目录下没有shell文件夹就新建shell文件夹。</p>\n<h4 id=\"3-新建项\"><a href=\"#3-新建项\" class=\"headerlink\" title=\"3.新建项\"></a>3.新建项</h4><p>在shell目录下 新建项 Git Bash Here，此时点击鼠标右键菜单会出现“Git Bush Here”选项，但是你继续点击她，还不会打开git命令块。</p>\n<h4 id=\"4-添加图标\"><a href=\"#4-添加图标\" class=\"headerlink\" title=\"4.添加图标\"></a>4.添加图标</h4><p>到此时你会发现右键没有图标，我们可以给右键 Git Bush Here 快捷方式添加一个 Icon，这样看起来就美观很多，在Git Bash Here 项下 新建字符串值 Icon 然后编辑Icon 值 ，E:\\Git\\mingw64\\share\\git\\git-for-windows.ico ，注意：需要根据安装的Git真实目录进行配置。</p>\n<h4 id=\"5-新建Command项\"><a href=\"#5-新建Command项\" class=\"headerlink\" title=\"5.新建Command项\"></a>5.新建Command项</h4><p>在 Git Bash Here  下新建Command项，随后修改Command项的默认值修改为 E:\\Git\\bin\\bash.exe –login -i，注意：需要根据安装的Git真实目录进行配置。 此时你可以放心的使用Git Bush Here快捷方式了。<br><img src=\"/Git右键没有Git-Bash-Here的解决办法/git-bash-here.png\" alt=\"如图所示\"></p>\n","comments":true,"categories":[{"name":"版本控制","slug":"版本控制","permalink":"whd-mtt.github.io/categories/版本控制/"}],"tags":[{"name":"git","slug":"git","permalink":"whd-mtt.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"whd-mtt.github.io/tags/版本控制/"}]},{"title":"注解的原理和应用","date":"2018-05-03T11:25:50.000Z","path":"2018/05/03/注解的原理和应用/","content":"<p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p>\n<a id=\"more\"></a>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h3 id=\"注解的分类\"><a href=\"#注解的分类\" class=\"headerlink\" title=\"注解的分类\"></a>注解的分类</h3><p>一般的注解护照要分为三类：</p>\n<h4 id=\"Java自带的标准注解\"><a href=\"#Java自带的标准注解\" class=\"headerlink\" title=\"Java自带的标准注解\"></a>Java自带的标准注解</h4><p>Java自带的标准注解主要包括包括@Override、@Deprecated和@SuppressWarnings三类，用这些注解标明后编译器就会进行检查；</p>\n<ul>\n<li>@Override 用于标明重写某个方法；</li>\n<li>@Deprecated 用于标明某个类或方法过时、标明要忽略的警告；</li>\n<li>@SuppressWarnings 用于申明要忽略的警告；</li>\n</ul>\n<h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解是用于定义注解的注解，主要包括@Retention、@Target、@Inherited、@Documented四个；</p>\n<ul>\n<li>@Retention     用于标明注解被保留的阶段;</li>\n<li>@Target          用于标明注解使用的范围;</li>\n<li>@Inherited     用于标明注解可继承;</li>\n<li>@Documented   用于标明是否生成javadoc文档；</li>\n</ul>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>自定义注解，程序员可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p>\n<h3 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h3><p>它主要的作用有以下四方面：</p>\n<ul>\n<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>\n</ul>\n<h3 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h3><p>注解的使用大体分为三部分：定义注解，使用注解和解析注解，标准注解非常简单，大家可以自己实现，同时现在存在很多的java框架（Spring,SpringBoot,SpringCloud,Hibernate）中间的注解，大家使用的比较多，框架中的注解一般已经做好注解的定义和注解的解析，我们程序员只需要使用它就是了，这里主要说明自定义注解的使用。</p>\n<h4 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h4><p>注解的定义通过@interface定义，然后在注解内部可以定义方法，很类似接口中的方法，但是在注解中他是一个成员变量，定义成员变量要遵守一些规则：<br>1.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。<br>2.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=）。<br>3.注解类可以没有成员，没有成员的注解称为标识注解<br>现在我们定义一个在方法上注解，里面有两个String类型的成员变量</p>\n<pre><code>@Documented\n@Target(ElementType.METHOD)\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AuthorAPI {\n    String author() default &quot;whd&quot;;\n    String comments() default  &quot;no comments&quot;;\n    int age() default 23;\n}\n</code></pre><h4 id=\"注解的使用-1\"><a href=\"#注解的使用-1\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h4><pre><code>public class UseAnnotation {\n\n    @AuthorAPI\n    public void getInfo(String name){\n        System.out.println(name);\n    }\n\n    @AuthorAPI(author = &quot;mtt&quot;, comments = &quot;you are pretty good&quot;, age = 20)\n    public void getDetail(String name){\n        System.out.println(name);\n    }\n\n    public void getInfomation(String name){\n        System.out.println(name);\n    }\n\n}\n</code></pre><h4 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h4><pre><code>public class TestAnnotation {\n\n    public static void main(String[] args) {\n        getSomeAuthorInfo(UseAnnotation.class);\n    }\n\n    private static void getSomeAuthorInfo(Class&lt;?&gt; clazz)  {\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(AuthorAPI.class)){\n                AuthorAPI annotation = method.getDeclaredAnnotation(AuthorAPI.class);\n                System.out.println(annotation.author() +&quot; &quot;+ annotation.comments() +&quot; &quot;+ annotation.age());\n                try {\n                    method.invoke(new UseAnnotation(), &quot;hello, baby&quot;);\n                } catch (IllegalAccessException | InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre><p>输出结果：</p>\n<pre><code>mtt you are pretty good 20\nhello, baby\nwhd no comments 23\nhello, baby\n</code></pre><p>我们发现只有添加AuthorAPI注解的方法才能获取到注解成员变量的值，当然你也可以实现其他的逻辑。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"annotation","slug":"annotation","permalink":"whd-mtt.github.io/tags/annotation/"}]}]