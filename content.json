[{"title":"Consulu服务注册和发现","date":"2018-07-05T14:53:22.000Z","path":"2018/07/05/Consulu服务注册和发现/","content":"<p>Consul（<a href=\"https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/）是一款用作发现和配置服务的工具,其官方网站上列出了它的</a> 4 点主要功能：<br><a id=\"more\"></a><br>服务发现<br>Consul 提供服务的注册与发现。服务的发现可以通过 DNS 或 HTTP。<br>● 健康检查<br>Consul 可以检查其客户端的健康状况 - 这通过客户端提供服务完成。除此之外，Consul 还可以检查整个机器节点的健康情况。关于健康检查的更多信息，<br>可以参考 <a href=\"https://www.consul.io/docs/agent/checks.html。\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/docs/agent/checks.html。</a><br>● KV 存储<br>Consul 提供了层级式（hierarchy）的键值对存储，应用程序可以用来完成几乎<br>任意的配置。<br>● 多数据中心支持<br>Consul 对多数据中心的支持是内建的，用户无需额外工作即可获得。</p>\n<h3 id=\"安装和启动-Consul\"><a href=\"#安装和启动-Consul\" class=\"headerlink\" title=\"安装和启动 Consul\"></a>安装和启动 Consul</h3><p>要使用 Consul，我们需要先安装它。Consul 是用 golang 开发的（GitHub 地址为：<a href=\"https://github.com/hashicorp/consul），其分发的安装包里包含的是针\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/consul），其分发的安装包里包含的是针</a><br>对各个不同平台预先编译好的二进制文件，解压即可使用。安装包可以到<a href=\"https://www.consul.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.consul.io/downloads.html</a> 下载获得。以 Linux 为例，我们可以<br>通过一下命令来完成安装：</p>\n<h1 id=\"下载-consul，这里用-linux-64bit-的-1-0-7-版本\"><a href=\"#下载-consul，这里用-linux-64bit-的-1-0-7-版本\" class=\"headerlink\" title=\"下载 consul，这里用 linux 64bit 的 1.0.7 版本\"></a>下载 consul，这里用 linux 64bit 的 1.0.7 版本</h1><p>$ curl -LO <a href=\"https://releases.hashicorp.com/consul/1.0.7/\" target=\"_blank\" rel=\"noopener\">https://releases.hashicorp.com/consul/1.0.7/</a><br>consul_1.0.7_linux_amd64.zip<br>% Total % Received % Xferd Average Speed Time Time Time Current<br>Dload Upload Total Spent Left Speed<br>100 11.7M 100 11.7M 0 0 1477k 0 0:00:08 0:00:08 –:–:– 2466k</p>\n<h1 id=\"解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\"><a href=\"#解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）\" class=\"headerlink\" title=\"解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）\"></a>解压（zip 包里面只包含了一个可执行/绿色的文件，名字就叫 consul）</h1><p>$ unzip consul_1.0.7_linux_amd64.zip<br>Archive: consul_1.0.7_linux_amd64.zip<br>inflating: consul</p>\n<h1 id=\"将-consul-移动到-PATH-中，方便后续敲命令\"><a href=\"#将-consul-移动到-PATH-中，方便后续敲命令\" class=\"headerlink\" title=\"将 consul 移动到$PATH 中，方便后续敲命令\"></a>将 consul 移动到$PATH 中，方便后续敲命令</h1><p>$ mv consul /usr/local/bin 完成后，我们可以用 consul –version 命令来验证一下：<br>$ consul –version<br>Consul v1.0.7 Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when<br>speaking to compatible agents)</p>\n","comments":true,"categories":[{"name":"微服务","slug":"微服务","permalink":"whd-mtt.github.io/categories/微服务/"}],"tags":[{"name":"spring","slug":"spring","permalink":"whd-mtt.github.io/tags/spring/"},{"name":"consul","slug":"consul","permalink":"whd-mtt.github.io/tags/consul/"},{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"微服务","slug":"微服务","permalink":"whd-mtt.github.io/tags/微服务/"}]},{"title":"ubuntu16.04.3安装RabbitMQ服务器","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Bootstrap-table分页删除尾页数据后刷新无数据问题/","content":"<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构，关于消息队列，市面上有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ这样一些消息队列，但是目前大家用得最多的就是Kafka，<strong>RabbitMQ</strong>，ActiveMQ，但是我们常用的<strong>SpringBoot</strong>不支持ActiveMQ（支持Kafka，RabbitMQ），所以先动手实现在linux上安装RabbitMQ服务器。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>为了顺利，建议大家以官方文档，根据这个链接<a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a>实现安装;</p>\n</blockquote>\n<h3 id=\"添加新的源\"><a href=\"#添加新的源\" class=\"headerlink\" title=\"添加新的源\"></a>添加新的源</h3><ul>\n<li>添加新的源 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'deb http://www.rabbitmq.com/debian/ testing main'</span> | sudo tee /etc/apt/sources.list.d/rabbitmq.list</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"下载公钥\"><a href=\"#下载公钥\" class=\"headerlink\" title=\"下载公钥\"></a>下载公钥</h3><ul>\n<li>下载公钥，防止后面的安装出现安全警告（可选，不执行此步骤也不会影响安装）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"更新和安装\"><a href=\"#更新和安装\" class=\"headerlink\" title=\"更新和安装\"></a>更新和安装</h3><ul>\n<li><p>更新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这时候我们可以通过ps -ef|grep rabbit命令来看哈情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef|grep rabbit</span><br></pre></td></tr></table></figure></p>\n<p>使用上述命令边可以查看到如下信息：</p>\n<pre><code>rabbitmq  1609     1  0 21:46 ?        00:00:02 /usr/lib/erlang/erts-7.3/bin/beam -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbi boot -sname rabbit@iZwz9ajwdnsg4s5368tvcpZ -boot start_sasl -kernel inet_default_connect_options [{nodelay,true}] -sasl errlog_type error -sasl sasl_error_logger false -rabbit error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ.log&quot;} -rabbit sasl_error_logger {file,&quot;/var/log/rabbitmq/rabbit@iZwz9ajwdnsg4s5368tvcpZ-sasl.log&quot;} -rabbit enabled_plugins_file &quot;/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins&quot; -rabbit plugins_expand_dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/var/lib/rabbitmq/mnesia/rabbit@iZwz9ajwdnsg4s5368tvcpZ&quot; -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672\nrabbitmq  1703     1  0 21:46 ?        00:00:00 /usr/lib/erlang/erts-7.3/bin/epmd -daemon\nrabbitmq  1811  1609  0 21:46 ?        00:00:00 inet_gethost 4\nrabbitmq  1812  1811  0 21:46 ?        00:00:00 inet_gethost 4\nroot      2059   394  0 22:02 pts/1    00:00:00 grep --color=auto rabbit\n</code></pre><blockquote>\n<p>注意：最新版本为了安全，默认只允许本地可访问，也就是说我们远程无法访问。还需要进行配置才行。</p>\n</blockquote>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>我这里使用的是ubuntu的系统，登录远程服务器，cd /etc/rabbitmq/下，</p>\n<ul>\n<li>新建rabbitmq.config文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch rabbitmq.config</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果不知道如何写配置文件，还是参照官网<a href=\"http://www.rabbitmq.com/access-control.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/access-control.html</a>完成自己的配置文件<br>配置文件的内容为：</p>\n<pre><code>[{rabbit, [{loopback_users, []}]}].\n</code></pre><p>如果我们想有一个web端可视化操作界面，我们还需要配置插件,先进入到安全目录：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/lib/rabbitmq/bin/ </span><br><span class=\"line\">$ ./rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></p>\n<p>最后别忘记了重启你的rabbitmq<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ invoke-rc.d rabbitmq-server restart</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>重新你启动后：输入./rabbitmqctl status查看启动状态：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./rabbitmqctl status</span><br></pre></td></tr></table></figure></p>\n<p>看到如下信息表示rabbitmq启动成功：</p>\n<pre><code>Status of node rabbit@iZwz9ajwdnsg4s5368tvcpZ\n[{pid,1616},\n {running_applications,\n     [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.15&quot;},\n      {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.15&quot;},\n      {rabbit,&quot;RabbitMQ&quot;,&quot;3.6.15&quot;},\n      {cowboy,&quot;Small, fast, modular HTTP server.&quot;,&quot;1.0.4&quot;},\n      {ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.3.2&quot;},\n      {ssl,&quot;Erlang/OTP SSL application&quot;,&quot;7.3&quot;},\n      {public_key,&quot;Public key infrastructure&quot;,&quot;1.1.1&quot;},\n      {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.4&quot;},\n      {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.15&quot;},\n      {rabbit_common,\n          &quot;Modules shared by rabbitmq-server and rabbitmq-erlang-client&quot;,\n          &quot;3.6.15&quot;},\n      {compiler,&quot;ERTS  CXC 138 10&quot;,&quot;6.0.3&quot;},\n      {inets,&quot;INETS  CXC 138 49&quot;,&quot;6.2&quot;},\n      {cowlib,&quot;Support library for manipulating Web protocols.&quot;,&quot;1.0.2&quot;},\n      {crypto,&quot;CRYPTO&quot;,&quot;3.6.3&quot;},\n      {asn1,&quot;The Erlang ASN1 compiler version 4.0.2&quot;,&quot;4.0.2&quot;},\n      {recon,&quot;Diagnostic tools for production use&quot;,&quot;2.3.2&quot;},\n      {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.13.3&quot;},\n      {syntax_tools,&quot;Syntax tools&quot;,&quot;1.7&quot;},\n      {xmerl,&quot;XML parser&quot;,&quot;1.3.10&quot;},\n      {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.7&quot;},\n      {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;2.8&quot;},\n      {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;4.2&quot;}]},\n {os,{unix,linux}},\n {erlang_version,\n     &quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [kernel-poll:true]\\n&quot;},\n {memory,\n     [{connection_readers,0},\n      {connection_writers,0},\n      {connection_channels,0},\n      {connection_other,2592},\n      {queue_procs,2592},\n      {queue_slave_procs,0},\n      {plugins,719912},\n      {other_proc,21169952},\n      {metrics,51816},\n      {mgmt_db,145272},\n      {mnesia,58224},\n      {other_ets,2325224},\n      {binary,59168},\n      {msg_index,40704},\n      {code,27779661},\n      {atom,1000601},\n      {other_system,4364826},\n      {allocated_unused,16974432},\n      {reserved_unallocated,0},\n      {total,72642560}]},\n {alarms,[]},\n {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;},{http,15672,&quot;::&quot;}]},\n {vm_memory_calculation_strategy,rss},\n {vm_memory_high_watermark,0.4},\n {vm_memory_limit,838947635},\n {disk_free_limit,50000000},\n {disk_free,36661555200},\n {file_descriptors,\n     [{total_limit,924},{total_used,2},{sockets_limit,829},{sockets_used,0}]},\n {processes,[{limit,1048576},{used,321}]},\n {run_queue,0},\n {uptime,602},\n {kernel,{net_ticktime,60}}]\n</code></pre><h2 id=\"后台管理\"><a href=\"#后台管理\" class=\"headerlink\" title=\"后台管理\"></a>后台管理</h2><p>在浏览器段查看rabbit的后台管理界面：</p>\n<ul>\n<li><p>首先，在自己的系统防火墙的端口号，后台管理界面的访问端口是15672,因此需要在执行以下命令开放该端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ firewall-cmd --add-port=15672/tcp --zone=public --permanent</span><br><span class=\"line\"></span><br><span class=\"line\">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于我的服务器是阿里云的ubuntu，因此需要登陆阿里云，进入你的管理控制台安全组入口配置规则，开放端口，在浏览器输入以下地址，便可访问后台管理界面。</p>\n<pre><code>你的服务器公网地址:15672\n</code></pre><p>效果如下:<br><img src=\"/img/rabbitmq.png\" alt=\"\"></p>\n</li>\n</ul>\n","comments":true,"categories":[{"name":"中间件","slug":"中间件","permalink":"whd-mtt.github.io/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"whd-mtt.github.io/tags/RabbitMQ/"},{"name":"linux","slug":"linux","permalink":"whd-mtt.github.io/tags/linux/"},{"name":"消息队列","slug":"消息队列","permalink":"whd-mtt.github.io/tags/消息队列/"}]},{"title":"IntelliJ IDEA的使用","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/IntelliJ-idea的快捷键的使用/","content":"<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p>\n<a id=\"more\"></a>\n<h2 id=\"快捷键的使用\"><a href=\"#快捷键的使用\" class=\"headerlink\" title=\"快捷键的使用\"></a>快捷键的使用</h2><blockquote>\n<p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p>\n</blockquote>\n<h3 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h3><ul>\n<li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li>\n<li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li>\n<li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li>\n<li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li>\n<li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li>\n<li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li>\n<li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li>\n<li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li>\n<li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li>\n</ul>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><ul>\n<li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li>\n<li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li>\n<li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li>\n<li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li>\n</ul>\n<h3 id=\"列操作\"><a href=\"#列操作\" class=\"headerlink\" title=\"列操作\"></a>列操作</h3><ul>\n<li>列选<br> Ctrl + Shift + Alt + J : 列选 </li>\n</ul>\n","comments":true,"categories":[{"name":"编程工具","slug":"编程工具","permalink":"whd-mtt.github.io/categories/编程工具/"}],"tags":[{"name":"IntelliJ idea","slug":"IntelliJ-idea","permalink":"whd-mtt.github.io/tags/IntelliJ-idea/"},{"name":"jetbrains","slug":"jetbrains","permalink":"whd-mtt.github.io/tags/jetbrains/"}]},{"title":"Bootstrap-table分页删除尾页数据后刷新无数据问题","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/ubuntu16.04.3安装rabbitmq服务器/","content":"<blockquote>\n<p>当我们使用bootstrap-table做表格分页展示的时候，当我们删除最后一页数据的时候，刷新数据发现无数据展示, 针对这种问题，我们有三种解决方式；</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n","comments":true,"categories":[{"name":"前端","slug":"前端","permalink":"whd-mtt.github.io/categories/前端/"}],"tags":[{"name":"bootstrap-table","slug":"bootstrap-table","permalink":"whd-mtt.github.io/tags/bootstrap-table/"},{"name":"js","slug":"js","permalink":"whd-mtt.github.io/tags/js/"}]},{"title":"Hello World","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><a id=\"more\"></a>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","comments":true,"categories":[{"name":"github","slug":"github","permalink":"whd-mtt.github.io/categories/github/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"whd-mtt.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"whd-mtt.github.io/tags/博客/"}]},{"title":"Hibernate中get()和load()的区别","date":"2018-06-03T11:25:50.000Z","path":"2018/06/03/Hibernate中get()和load()的区别/","content":"<p>最近面试中遇到了关于hibernate中get()和load()两个方法的区别,我在论坛看到了各种论述，我总结了他们的观点以及自己的理解来简单说明下，如果有哪里不对的地方欢迎指正。</p>\n<a id=\"more\"></a>\n<h2 id=\"返回结果\"><a href=\"#返回结果\" class=\"headerlink\" title=\"返回结果\"></a>返回结果</h2><p>首先要清楚一点的是get()和load()方法都是hibernate中session中获取实体对象两个方法,如果是get()方法加载实体对象，但是如果加载对象失败的话，那么结果会返回为null，而通过load()方式加载实体对象，加载不到的数据话便会抛出ObjectNotFoundException。</p>\n<hr>\n<h2 id=\"执行机制\"><a href=\"#执行机制\" class=\"headerlink\" title=\"执行机制\"></a>执行机制</h2><h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get( )方法\"></a>get( )方法</h3><p>对于get( )方法，hibernate会确认一下该id对应的数据是否存在，首先会在session一级缓存中查找，如果在session缓存中找到了该id对应的对象；</p>\n<ul>\n<li><p>如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象;</p>\n</li>\n<li><p>如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据;</p>\n</li>\n<li>如果该id对应的对象并且不是被延迟加载的代理对象，或者在session缓存中没有找到该对象，则查找二级缓存</li>\n</ul>\n<p>如果二级缓存中没有的话，就会直接发送sql语句去数据库查询数据返回实体对象，如果数据库中也没有就返回null。</p>\n<h3 id=\"load-方法\"><a href=\"#load-方法\" class=\"headerlink\" title=\"load()方法\"></a>load()方法</h3><p>对于load方法加载实体对象的时，会根据*.hbm.xml映射文件上类级别的lazy属性的配置(默认为true)选择加载方式；</p>\n<ul>\n<li><p>若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)，这个代理对象只保存了实体对象的id值，当我们使用该对象的其他属性值时就会查找二级缓存，二级缓存没有就发出sql语句去数据库查找数据，如果数据库仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。这也是我们时常所说的<strong>延迟加载 </strong></p>\n</li>\n<li><p>若为false，就跟get( )方法加载顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException;</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"使用get-和load-时的注意事项\"><a href=\"#使用get-和load-时的注意事项\" class=\"headerlink\" title=\"使用get( )和load( )时的注意事项\"></a>使用get( )和load( )时的注意事项</h2><p>当我们了解了load和get的加载机制以后，在以后使用过程后需要注意一些问题：</p>\n<ul>\n<li><p>如果使用get方式来加载对象，当我们试图得到一个id不存在的对象时，此时会报NullPointException,这是因为通过get( )方式加载实体对象时候，我们会去数据库中查询出该对象，但是这个id值不存在，所以此时实体对象是null，也就会报NullPointException。</p>\n</li>\n<li><p>如果使用load方式来加载对象，当我们试图得到一个id不存在的实体对象时，此时会报ObjectNotFoundException，为什么使用load的方式和get的方式来得到一个不存在的对象报的异常不同呢？？其原因还是因为load的延迟加载机制，使用load()时，此时的实体对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的其他属性时，这个属性其实是为空，所以就会报ObjectNotFoundException</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之对于get( )和load( )的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get( )方法，hibernate一定要获取到真实的数据，否则返回null。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"whd-mtt.github.io/tags/hibernate/"}]},{"title":"Git右键没有Git Bash Here的解决办法","date":"2018-06-02T11:25:50.000Z","path":"2018/06/02/Git右键没有Git-Bash-Here的解决办法/","content":"<p>大家经常会遇到的一个问题，大家在安装git完成的时候，一般用鼠标右键就可以看到Git Bash Here和Git Gui这两个选项，但是有时候安装git后并没有两个选项，这里我们将要介绍如何配置Git Bash Here这个命令。</p>\n<a id=\"more\"></a>\n<h3 id=\"出现原因\"><a href=\"#出现原因\" class=\"headerlink\" title=\"出现原因\"></a>出现原因</h3><p>对于各位右键看不到这个命令，出现这个问题的原因，主要是我在安装git的时候，安装路径没有在C盘下，安装在C盘下系统就会自动帮你创建这个命令，再右键就能看到这两个命令，如果你的git安装在其他盘符下，那么就需要你自己完成手动配置。</p>\n<h4 id=\"1-打开注册表\"><a href=\"#1-打开注册表\" class=\"headerlink\" title=\"1.打开注册表\"></a>1.打开注册表</h4><p>（win按键+R打开运行小窗口）在“运行”中输入‘regedit’，打开注册表。</p>\n<h4 id=\"2-创建shell文件夹\"><a href=\"#2-创建shell文件夹\" class=\"headerlink\" title=\"2.创建shell文件夹\"></a>2.创建shell文件夹</h4><p>在注册表编辑器界面  HKEY_CLASSES_ROOT\\Directory\\Background\\shell中进行设置，如果Background目录下没有shell文件夹就新建shell文件夹。</p>\n<h4 id=\"3-新建项\"><a href=\"#3-新建项\" class=\"headerlink\" title=\"3.新建项\"></a>3.新建项</h4><p>在shell目录下 新建项 Git Bash Here，此时点击鼠标右键菜单会出现“Git Bush Here”选项，但是你继续点击她，还不会打开git命令块。</p>\n<h4 id=\"4-添加图标\"><a href=\"#4-添加图标\" class=\"headerlink\" title=\"4.添加图标\"></a>4.添加图标</h4><p>到此时你会发现右键没有图标，我们可以给右键 Git Bush Here 快捷方式添加一个 Icon，这样看起来就美观很多，在Git Bash Here 项下 新建字符串值 Icon 然后编辑Icon 值 ，E:\\Git\\mingw64\\share\\git\\git-for-windows.ico ，注意：需要根据安装的Git真实目录进行配置。</p>\n<h4 id=\"5-新建Command项\"><a href=\"#5-新建Command项\" class=\"headerlink\" title=\"5.新建Command项\"></a>5.新建Command项</h4><p>在 Git Bash Here  下新建Command项，随后修改Command项的默认值修改为 E:\\Git\\bin\\bash.exe –login -i，注意：需要根据安装的Git真实目录进行配置。 此时你可以放心的使用Git Bush Here快捷方式了。</p>\n","comments":true,"categories":[{"name":"版本控制","slug":"版本控制","permalink":"whd-mtt.github.io/categories/版本控制/"}],"tags":[{"name":"git","slug":"git","permalink":"whd-mtt.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"whd-mtt.github.io/tags/版本控制/"}]},{"title":"注解的原理和应用","date":"2018-05-03T11:25:50.000Z","path":"2018/05/03/注解的原理和应用/","content":"<p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p>\n<a id=\"more\"></a>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h3 id=\"注解的分类\"><a href=\"#注解的分类\" class=\"headerlink\" title=\"注解的分类\"></a>注解的分类</h3><p>一般的注解护照要分为三类：</p>\n<h4 id=\"Java自带的标准注解\"><a href=\"#Java自带的标准注解\" class=\"headerlink\" title=\"Java自带的标准注解\"></a>Java自带的标准注解</h4><p>Java自带的标准注解主要包括包括@Override、@Deprecated和@SuppressWarnings三类，用这些注解标明后编译器就会进行检查；</p>\n<ul>\n<li>@Override 用于标明重写某个方法；</li>\n<li>@Deprecated 用于标明某个类或方法过时、标明要忽略的警告；</li>\n<li>@SuppressWarnings 用于申明要忽略的警告；</li>\n</ul>\n<h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解是用于定义注解的注解，主要包括@Retention、@Target、@Inherited、@Documented四个；</p>\n<ul>\n<li>@Retention     用于标明注解被保留的阶段;</li>\n<li>@Target          用于标明注解使用的范围;</li>\n<li>@Inherited     用于标明注解可继承;</li>\n<li>@Documented   用于标明是否生成javadoc文档；</li>\n</ul>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>自定义注解，程序员可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p>\n<h3 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h3><p>它主要的作用有以下四方面：</p>\n<ul>\n<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>\n</ul>\n<h3 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h3><p>注解的使用大体分为三部分：定义注解，使用注解和解析注解，标准注解非常简单，大家可以自己实现，同时现在存在很多的java框架（Spring,SpringBoot,SpringCloud,Hibernate）中间的注解，大家使用的比较多，框架中的注解一般已经做好注解的定义和注解的解析，我们程序员只需要使用它就是了，这里主要说明自定义注解的使用。</p>\n<h4 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h4><p>注解的定义通过@interface定义，然后在注解内部可以定义方法，很类似接口中的方法，但是在注解中他是一个成员变量，定义成员变量要遵守一些规则：<br>1.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。<br>2.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=）。<br>3.注解类可以没有成员，没有成员的注解称为标识注解<br>现在我们定义一个在方法上注解，里面有两个String类型的成员变量</p>\n<pre><code>@Documented\n@Target(ElementType.METHOD)\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AuthorAPI {\n    String author() default &quot;whd&quot;;\n    String comments() default  &quot;no comments&quot;;\n    int age() default 23;\n}\n</code></pre><h4 id=\"注解的使用-1\"><a href=\"#注解的使用-1\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h4><pre><code>public class UseAnnotation {\n\n    @AuthorAPI\n    public void getInfo(String name){\n        System.out.println(name);\n    }\n\n    @AuthorAPI(author = &quot;mtt&quot;, comments = &quot;you are pretty good&quot;, age = 20)\n    public void getDetail(String name){\n        System.out.println(name);\n    }\n\n    public void getInfomation(String name){\n        System.out.println(name);\n    }\n\n}\n</code></pre><h4 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h4><pre><code>public class TestAnnotation {\n\n    public static void main(String[] args) {\n        getSomeAuthorInfo(UseAnnotation.class);\n    }\n\n    private static void getSomeAuthorInfo(Class&lt;?&gt; clazz)  {\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(AuthorAPI.class)){\n                AuthorAPI annotation = method.getDeclaredAnnotation(AuthorAPI.class);\n                System.out.println(annotation.author() +&quot; &quot;+ annotation.comments() +&quot; &quot;+ annotation.age());\n                try {\n                    method.invoke(new UseAnnotation(), &quot;hello, baby&quot;);\n                } catch (IllegalAccessException | InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre><p>输出结果：</p>\n<pre><code>mtt you are pretty good 20\nhello, baby\nwhd no comments 23\nhello, baby\n</code></pre><p>我们发现只有添加AuthorAPI注解的方法才能获取到注解成员变量的值，当然你也可以实现其他的逻辑。</p>\n","comments":true,"categories":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"whd-mtt.github.io/tags/java/"},{"name":"annotation","slug":"annotation","permalink":"whd-mtt.github.io/tags/annotation/"}]}]